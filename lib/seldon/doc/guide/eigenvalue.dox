/*! \file eigenvalue.dox
    \brief Eigenvalue Solvers.
*/

/*!
\page eigenvalue Eigenvalue Solvers

<p>%Seldon is interfaced with libraries performing the research of eigenvalues and eigenvectors of very large sparse linear systems : <b><a href="http://www.caam.rice.edu/software/ARPACK/">Arpack</a></b>, <b><a href="http://slepc.upv.es/">SLEPc</a></b>, <b><a href="http://trilinos.sandia.gov/packages/anasazi/">Anasazi</a></b> (only in sequential) and <b><a href="http://www.ecs.umass.edu/~polizzi/feast/">Feast</a></b> (only in sequential). An example file is located in test/program/eigenvalue_test.cpp. For an efficient computation, the user should compile with one of the direct solvers interfaced by Seldon (ie. Mumps, Pastix, SuperLU or UmfPack). For example, if you are compiling with Arpack, you may type (Blas and Lapack are assumed to be provided by MKL library): </p>

<pre class="fragment">g++ test/program/eigenvalue_test.cpp -o run -DSELDON_WITH_ARPACK -DSELDON_WITH_CBLAS -DSELDON_WITH_LAPACK -LArpackDir -larpack \
 -LMklDir -lmkl_lapack95 -lmkl_gf -lmkl_gnu_thread -lmkl_core -lgfortran -I../.. -fopenmp etime.o </pre>

<p>where <b>MklDir</b> denotes the directoy where the Mkl library is present and <b>ArpackDir</b> the directory where Arpack library is. The file etime.o can be generated by compiling a file etime.f: </p>

\precode

      subroutine etime(tarray, result)
      
      real tarray(2)
      real result
      
      end subroutine etime

\endprecode

<p> A file etime.f is present in the folder lib and compiled if USE_ARPACK := YES has been set in the Makefile. </p>

<p>You can compile the same file with Anasazi instead of Arpack by typing:</p>

<pre class="fragment">g++ test/program/eigenvalue_test.cpp -o run -DSELDON_WITH_ANASAZI -DSELDON_WITH_CBLAS -DSELDON_WITH_LAPACK -ITrilinosInclude \
 -LTrilinosLib -lteuchosremainder -lteuchosparameterlist -lteuchosnumerics -lteuchoscomm -lteuchoscore \
 -LMklDir -lmkl_lapack95 -lmkl_gf -lmkl_gnu_thread -lmkl_core -lgfortran -I. -fopenmp
 </pre>

<p> where <b>TrilinosInclude</b> and <b>TrilinosLib</b> are the directories of Trilinos containing the headers and the library files. If you want to compile with Feast, you can type: </p>

<pre class="fragment">g++ test/program/eigenvalue_test.cpp -o run -DSELDON_WITH_MKL -DSELDON_WITH_FEAST -DSELDON_WITH_CBLAS -DSELDON_WITH_LAPACK \
 -LMklDir -lmkl_lapack95 -lmkl_gf -lmkl_gnu_thread -lmkl_core -lgfortran -I. -fopenmp </pre>

<p>For Slepc, you should compile with a line:</p>

<pre class="fragment">mpicxx test/program/eigenvalue_test.cpp -o run -DSELDON_WITH_MPI -DSELDON_WITH_SLEPC -DSELDON_WITH_CBLAS -DSELDON_WITH_LAPACK \
 -I. -I$(SLEPC_DIR)/$(PETSC_ARCH)/include -I$(SLEPC_DIR)/include -I$(PETSC_DIR)/$(PETSC_ARCH)/include -I$(PETSC_DIR)/include \
 -L$(SLEPC_DIR)/$(PETSC_ARCH)/lib -lslepc -L$(PETSC_DIR)/$(PETSC_ARCH)/lib -lpetsc \
 -LMklDir -lmkl_lapack95 -lmkl_gf -lmkl_gnu_thread -lmkl_core -lgfortran  -fopenmp </pre>

<p>Here we have provided examples of compilation without any direct solver, but for an efficient computation, a direct solver should also be linked (e.g. Mumps or Pastix). We advise you to compile your target by using the Makefile provided and set USE_FEAST = YES, USE_SLEPC = YES and/or USE_ARPACK = YES in this Makefile. If you want to use SLEPc, you will need to set USE_MPI=yes and with SLEPc you can compute only eigenvalues of a real matrix or a complex matrix (you have to choose the arithmetic at the compilation). If you have compiled Seldon with a SLEPc version of doubles, and you want to compute eigenvalues of a complex matrix, Seldon with return an error during the execution. </p>

<h2>Syntax</h2>


<p>The syntax of all eigenvalue solvers is similar. We assume here that <b>SELDON_WITH_VIRTUAL</b> has been defined (for instance in SeldonFlag.hxx). </p>


<pre class="syntax-box">
void GetEigenvaluesEigenvectors(EigenProblem_Base&amp;, Vector&amp; lambda, Vector&amp; lambda_imag,
                                Matrix&amp; eigen_vec, int type_solver);
</pre>


<p>The interface has been written only for double precision (real or complex numbers),
 since single precision is not accurate enough when seeking eigenvalues of very large sparse linear systems. Unitary tests are present in files test/unit/eigenvalue_solver_test.cc, test/unit/eigenvalue_sparse.cc, test/unit/eigenvalue_feast.cc, test/unit/eigenvalue_slepc.cc and test/unit/eigenvalue_anasazi.cc. An example with parallel computation of eigenvalues is provided in the file test/unit/distributed_eigenvalue.cc. The last argument of GetEigenvaluesEigenvectors is optional. If it is not provided, Seldon will select the best available eigenvalue solver. </p>


<h2>Basic use</h2>


<p> We provide an example of eigenvalue computation with a sparse matrix.</p>


\precode
// first we construct a sparse matrix
int n = 1000; // size of linear system
// we assume that you will construct A correctly
Matrix<double, General, ArrayRowSparse> A(n, n);
// if A is symmetric, prefer a symmetric storage
// so that dsaupd routine will be called (more efficient)

// then we declare the eigenproblem K x = lambda M x
// where K is the stiffness matrix, and M mass matrix
// the syntax is SparseEigenProblem<T, MatrixStiff> 
// where T is double or complex<double>
// and MatrixStiff the type of the stiffness matrix K
SparseEigenProblem<double, Matrix<double, General, ArrayRowSparse> > var_eig;

// if you want to treat distributed matrices (parallel), use
// SparseEigenProblem<double, DistributedMatrix<double, General, ArrayRowSparse>,
//                            DistributedMatrix<double, Symmetric, ArrayRowSymSparse> > var_eig;

// SparseEigenProblem is devoted to the research of eigenvalues for sparse
// matrices (using Seldon format). If you want to consider dense matrices
// you can declare DenseEigenProblem<T, Tstiff, Prop, Storage> var_eig;
// If you have your own class of Matrix (in which only matrix vector product
// has been defined), use VirtualEigenProblem<T, MatStiff> var_eig;
// where MatStiff is the type of the stiffness matrix

// standard eigenvalue problem => K = A, and M = I
var_eig.InitMatrix(A);

// setting parameters of eigenproblem
var_eig.SetStoppingCriterion(1e-12);
var_eig.SetNbAskedEigenvalues(10);
// maximum number of iterations can be changed
var_eig.SetNbMaximumIterations(10000);

// you can ask largest eigenvalues of M^-1 K, smallest eigenvalues
// or eigenvalues closest to a shift sigma
var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0);
// for small eigenvalues
var_eig.SetTypeSpectrum(var_eig.SMALL_EIGENVALUES, 0);
// eigenvalues clustered around a shift sigma :
double sigma = 0.5;
var_eig.SetTypeSpectrum(var_eig.CENTERED_EIGENVALUES, sigma);

// if you are using Anasazi, you can select the appropriate solver
AnasaziParam& param = var_eig.GetAnasaziParameters();
param.SetEigensolverType(param.SOLVER_LOBPCG);
param.SetNbMaximumRestarts(100);
// symmetric system => SOLVER_LOBPCG or SOLVER_BD
// nonsymmetric system => SOLVER_BKS

// then you select the computational mode
// REGULAR => you only need of matrix vector product K x (if M = I)
// SHIFTED => the matrix (K - sigma M) will be factorized by
//            using an available direct solver
var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

// declaring arrays that will contains eigenvalues and eigenvectors
Vector<double> lambda, lambda_imag;
Matrix<double> eigen_vec;
GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);


// for a generalized eigenvalue problem, you provide both K and M
// default type of M is Matrix<double, Symmetric, ArrayRowSymSparse>
Matrix<double, Symmetric, ArrayRowSymSparse> M(n, n);
Matrix<double, General, ArrayRowSparse> K(n, n);

var_eig.InitMatrix(K, M);

// then you can compute eigenvalues as usual
GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);

// you can also give a specific type for mass Matrix :
SparseEigenProblem<double, Matrix<double, General, RowSparse>, 
                   Matrix<double, Symmetric, RowSymSparse> > var_eig2;

// then perform the same operations on var_eig2

\endprecode

<p>
You should pay attention to the computational mode selected since in most of the situations, the mass matrix is required to be real symmetric positive. If you have selected Arpack (which is the default eigenvalue solver) as solver, and if you provide a real symmetric mass matrix but indefinite (with both positive and negative eigenvalues), the computation will be completed without warnings, but the eigenvalues will be incorrect. So it is up to the user to check that the matrices are fulfilling the requirements of the computational mode given when <a href="#GetComputationalMode">GetComputationalMode</a> is called.  </p>


<h2>Advanced use</h2>


<p> It may sometimes be useful to compute eigenvalues by writing only a matrix-vector product. It could happen when the stiffness matrix is not effectively stored, and you wish to know large or small eigenvalues of this matrix with only this matrix-vector product. Here an example how to do that : </p>


\precode


// basic class defining a matrix
// we take here the discretization of 1-D laplacien
// with second-order finite difference method
template<class T>
class Matrix_Laplacian1D : public VirtualMatrix<T>
{
protected :
  int n;
  double L;
  
public :
  double dx;
  
  // this method is mandatory
  int GetM() const
  {
    return n;
  }

  // this method is mandatory
  int GetN() const
  {
    return n;
  }

  //  this method is not needed, it is placed here
  // to initializa attributes of this specific class
  void Init(int n_, double L_)
  {
    n = n_;
    L = L_;
    dx = L/(n+1);
  }

  // matrix vector product Y = A*X
  // mandatory function and main function
  void MltVector(const Vector<T>& X, Vector<T>& Y) const
  {
    int n = A.GetM();
    Y(0) = 2.0*X(0) - X(1);
    Y(n-1) = 2.0*X(n-1) - X(n-2);
    for (int i = 1; i < n-1; i++)
      Y(i) = 2.0*X(i) - X(i-1) - X(i+1);
  
    Mlt(1.0/(A.dx*A.dx), Y);
  }

  bool IsSymmetric() const { return true; }

};

int main()
{
    // testing matrix-free class (defined by the user)
    Matrix_Laplacian1D<double> K;
    K.Init(200, 2.0);
    
    // setting eigenvalue problem
    VirtualEigenProblem<double> var_eig;
    var_eig.SetStoppingCriterion(1e-12);
    var_eig.SetNbAskedEigenvalues(5);
    var_eig.SetComputationalMode(var_eig.REGULAR_MODE);
    var_eig.SetTypeSpectrum(var_eig.SMALL_EIGENVALUES, 0, var_eig.SORTED_MODULUS);

    // finding large eigenvalues of K
    var_eig.InitMatrix(K);
    Vector<double> lambda, lambda_imag;
    Matrix<double, General, ColMajor> eigen_vec;

    // effective computation of eigenvalues and eigenvectors    
    GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);    
  }

\endprecode

<p> Classes DenseEigenProblem, SparseEigenProblem and VirtualEigenProblem are deriving from
 base class EigenProblem_Base, and are overloading virtual methods of this base class. Therefore
 if you need to define a new class of eigenproblems, it could be a good idea to write a derived class.
 In order to help you out, we have detailed all the methods of EigenProblem_Base : </p>

<table class="category-table">
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#Init"> Init </a></td>
<td class="category-table-td"> Initialization of the eigenvalue problem </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#InitMatrix"> InitMatrix </a></td>
<td class="category-table-td"> Stiffness matrix (and optionall mass matrix) is given  </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetComputationalMode"> GetComputationalMode </a></td>
<td class="category-table-td"> Returns the computational mode used (regular, shifted, ...) </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetComputationalMode"> SetComputationalMode </a></td>
<td class="category-table-td"> Sets the computational mode used (regular, shifted, ...) </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetCommunicator"> GetCommunicator </a></td>
<td class="category-table-td"> Returns the MPI communicator associated with the eigenvalue problem </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetCommunicator"> SetCommunicator </a></td>
<td class="category-table-td"> Sets the MPI communicator associated with the eigenvalue problem </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetNbAskedEigenvalues"> GetNbAskedEigenvalues </a></td>
<td class="category-table-td"> Returns the number of wanted eigenvalues </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetNbAskedEigenvalues"> SetNbAskedEigenvalues </a></td>
<td class="category-table-td"> Sets the number of wanted eigenvalues </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetNbAdditionalEigenvalues"> GetNbAdditionalEigenvalues </a></td>
<td class="category-table-td"> Returns the number of additional eigenvalues (workaround due to Arpack bug) </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetNbAdditionalEigenvalues"> SetNbAdditionalEigenvalues </a></td>
<td class="category-table-td"> Sets the number of additional eigenvalues (workaround due to Arpack bug)</td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetAnasaziParameters"> GetAnasaziParameters </a></td>
<td class="category-table-td"> Returns the class storing parameters specific to Anasazi </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetSlepcParameters"> GetSlepcParameters </a></td>
<td class="category-table-td"> Returns the class storing parameters specific to SLEPc </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetTypeSpectrum"> GetTypeSpectrum </a></td>
<td class="category-table-td"> Returns the type of spectrum wanted by the user </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetTypeSpectrum"> SetTypeSpectrum </a></td>
<td class="category-table-td"> Sets the of spectrum wanted by the user </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetTypeSorting"> GetTypeSorting </a></td>
<td class="category-table-td"> Returns how eigenvalues are sorted (real part, modulus, etc) </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetShiftValue"> GetShiftValue </a></td>
<td class="category-table-td"> Returns the shift </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetShiftValue"> SetShiftValue </a></td>
<td class="category-table-td"> sets the shift </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetShiftValue"> GetImagShiftValue </a></td>
<td class="category-table-td"> Returns imaginary part of the shift (real unsymmetric problem) </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetShiftValue"> SetImagShiftValue </a></td>
<td class="category-table-td"> Sets the imaginary part of the shift (real unsymmetric problem) </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetComplexShift"> GetComplexShift </a></td>
<td class="category-table-td"> Forms a complex shift from real/imaginary part </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#SetIntervalSpectrum"> GetLowerBoundInterval </a></td>
<td class="category-table-td"> Returns the lower bound for the interval where eigenvalues are searched (Feast) </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#SetIntervalSpectrum"> GetUpperBoundInterval </a></td>
<td class="category-table-td"> Returns the upper bound for the interval where eigenvalues are searched (Feast) </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#SetIntervalSpectrum"> SetIntervalSpectrum </a></td>
<td class="category-table-td"> Sets the interval where eigenvalues are searched (Feast) </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#SetCholeskyFactoForMass"> SetCholeskyFactoForMass </a></td>
<td class="category-table-td"> Tells to find eigenvalues of L<sup>-1</sup> K L<sup>-T</sup> if M = L L<sup>T</sup> </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#SetCholeskyFactoForMass"> UseCholeskyFactoForMass </a></td>
<td class="category-table-td"> Returns true if eigenvalues of L<sup>-1</sup> K L<sup>-T</sup>are searched (M = L L<sup>T</sup>) </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#SetDiagonalMass"> SetDiagonalMass </a></td>
<td class="category-table-td"> Tells to find eigenvalues of M<sup>-1/2</sup> K M<sup>-1/2</sup>are searched (M diagonal) </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#SetDiagonalMass"> DiagonalMass </a></td>
<td class="category-table-td"> Returns true if eigenvalues of M<sup>-1/2</sup> K M<sup>-1/2</sup>are searched (M diagonal) </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#SetStoppingCriterion"> SetStoppingCriterion </a></td>
<td class="category-table-td"> Sets the stopping criterion used by iterative process </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#SetStoppingCriterion"> GetStoppingCriterion </a></td>
<td class="category-table-td"> Returns the stopping criterion used by iterative process </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#SetNbMaximumIterations"> SetNbMaximumIterations </a></td>
<td class="category-table-td"> Sets the maximum number of iterations allowed for the iterative process </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#SetNbMaximumIterations"> GetNbMaximumIterations </a></td>
<td class="category-table-td"> Returns the maximum number of iterations allowed for the iterative process </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetNbMatrixVectorProducts"> GetNbMatrixVectorProducts </a></td>
<td class="category-table-td"> Returns the number of iterations performed by the iterative process </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetNbArnoldiVectors"> GetNbArnoldiVectors </a></td>
<td class="category-table-td"> Returns the number of Arnoldi vectors </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetNbArnoldiVectors"> SetNbArnoldiVectors </a></td>
<td class="category-table-td"> Sets the number of Arnoldi vectors </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetM"> GetM </a></td>
<td class="category-table-td"> Returns the number of rows of the stiffness matrix </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetM"> GetN </a></td>
<td class="category-table-td"> Returns the number of columns of the stiffness matrix </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetPrintLevel"> GetPrintLevel </a></td>
<td class="category-table-td"> Returns the print level </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetPrintLevel"> SetPrintLevel </a></td>
<td class="category-table-td"> Sets the print level </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#IncrementProdMatVect"> IncrementProdMatVect </a></td>
<td class="category-table-td"> Increments the number of iterations performed by the iterative process </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#PrintErrorInit"> PrintErrorInit </a></td>
<td class="category-table-td"> Prints an error message if InitMatrix has not been called </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#IsSymmetricProblem"> IsSymmetricProblem </a></td>
<td class="category-table-td"> Returns true if the stiffness matrix is symmetric </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#IsHermitianProblem"> IsHermitianProblem </a></td>
<td class="category-table-td"> Returns true if the stiffness matrix is hermitian </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#FactorizeDiagonalMass"> FactorizeDiagonalMass </a></td>
<td class="category-table-td"> Computation of M<sup>1/2</sup>, once M is known </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetSqrtDiagonal"> GetSqrtDiagonal </a></td>
<td class="category-table-td"> Retrieves the square root of diagonal mass matrix </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#MltSqrtDiagonalMass"> MltInvSqrtDiagonalMass </a></td>
<td class="category-table-td"> Multiplication by M<sup>-1/2</sup> </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#MltSqrtDiagonalMass"> MltSqrtDiagonalMass </a></td>
<td class="category-table-td"> Multiplication by M<sup>1/2</sup> </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#ComputeDiagonalMass"> ComputeDiagonalMass </a></td>
<td class="category-table-td"> Computation of diagonal of M </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#ComputeMassForCholesky"> ComputeMassForCholesky </a></td>
<td class="category-table-td"> Multiplication by M<sup>-1/2</sup> </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#ComputeMassMatrix"> ComputeMassMatrix </a></td>
<td class="category-table-td"> Computation of mass matrix M </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#MltMass"> MltMass </a></td>
<td class="category-table-td"> Multiplication by mass matrix M </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#ComputeStiffnessMatrix"> ComputeStiffnessMatrix </a></td>
<td class="category-table-td"> Computation of stiffness matrix K </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#MltStiffness"> MltStiffness </a></td>
<td class="category-table-td"> Multiplication by stiffness matrix K </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#ComputeAndFactorizeStiffnessMatrix"> ComputeAndFactorizeStiffnessMatrix </a></td>
<td class="category-table-td"> Computation and factorization of a M + b K </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#ComputeSolution"> ComputeSolution </a></td>
<td class="category-table-td"> Computation and factorization of a M + b K </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#FactorizeCholeskyMass"> FactorizeCholeskyMass </a></td>
<td class="category-table-td"> Computation of Cholesky factor L of mass matrix (M = L L<sup>T</sup> </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#MltCholeskyMass"> MltCholeskyMass </a></td>
<td class="category-table-td"> Multiplication by L or L<sup>T</sup> </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#MltCholeskyMass"> SolveCholeskyMass </a></td>
<td class="category-table-td"> Resolution of L x = b or L<sup>T</sup> x = b </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#Clear"> Clear </a></td>
<td class="category-table-td"> Clears memory used by factorizations (if any present)</td> </tr>
</table>

<p>Below we list the methods of the class AnasaziParam:</p>

<table class="category-table">
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetNbBlocks"> GetNbBlocks </a></td>
<td class="category-table-td"> Returns the number of blocks to use </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetNbBlocks"> SetNbBlocks </a></td>
<td class="category-table-td"> Sets the number of blocks to use </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetNbMaximumRestarts"> GetNbMaximumRestarts </a></td>
<td class="category-table-td"> Returns the maximal number of restarts </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetNbMaximumRestarts"> SetNbMaximumRestarts </a></td>
<td class="category-table-td"> Sets the maximal number of restarts </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetOrthoManager"> GetOrthoManager </a></td>
<td class="category-table-td"> Returns the orthogonalization manager </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetEigensolverType"> GetEigensolverType </a></td>
<td class="category-table-td"> Returns the eigensolver to use  </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetEigensolverType"> SetEigensolverType </a></td>
<td class="category-table-td"> Sets the eigensolver to use </td> </tr>
</table>

<p>Below we list the methods of the class SlepcParam:</p>

<table class="category-table">
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetEigensolverType_s"> GetEigensolverType </a></td>
<td class="category-table-td"> Returns the eigensolver to use  </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetEigensolverType_s"> SetEigensolverType </a></td>
<td class="category-table-td"> Sets the eigensolver to use </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetBlockSize_s"> GetBlockSize </a></td>
<td class="category-table-td"> Returns the block size </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetBlockSize_s"> SetBlockSize </a></td>
<td class="category-table-td"> Sets the block size </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetMaximumBlockSize_s"> GetMaximumBlockSize </a></td>
<td class="category-table-td"> Returns the maximum block size </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetMaximumBlockSize_s"> SetMaximumBlockSize </a></td>
<td class="category-table-td"> Sets the maximum block size </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetNumberOfSteps_s"> GetNumberOfSteps </a></td>
<td class="category-table-td"> Returns the number of steps </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetNumberOfSteps_s"> SetNumberOfSteps </a></td>
<td class="category-table-td"> Sets the number of steps </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetExtractionType_s"> GetExtractionType </a></td>
<td class="category-table-td"> Returns the type of extraction to use in CISS </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetExtractionType_s"> SetExtractionType </a></td>
<td class="category-table-td"> Sets the type of extraction to use in CISS </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetQuadratureRuleType_s"> GetQuadratureRuleType </a></td>
<td class="category-table-td"> Returns the type of quadrature rules to use in CISS </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetQuadratureRuleType_s"> SetQuadratureRuleType </a></td>
<td class="category-table-td"> Sets the type of quadrature rules to use in CISS </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetInnerSteps_s"> GetInnerSteps </a></td>
<td class="category-table-td"> Returns the number of inner steps </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetInnerSteps_s"> SetInnerSteps </a></td>
<td class="category-table-td"> Sets the number of inner steps </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetOuterSteps_s"> GetOuterSteps </a></td>
<td class="category-table-td"> Returns the number of outer steps </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetOuterSteps_s"> SetOuterSteps </a></td>
<td class="category-table-td"> Sets the number of outer steps </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetNumberIntegrationPoints_s"> GetNumberIntegrationPoints </a></td>
<td class="category-table-td"> Returns the number of integration points to use </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetNumberIntegrationPoints_s"> SetNumberIntegrationPoints </a></td>
<td class="category-table-td"> Sets the number of integration points to use </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetMomentSize_s"> GetMomentSize </a></td>
<td class="category-table-td"> Returns the moment size </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetMomentSize_s"> SetMomentSize </a></td>
<td class="category-table-td"> Sets the moment size </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetNumberPartitions_s"> GetNumberPartitions </a></td>
<td class="category-table-td"> Returns the number of partitions </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetNumberPartitions_s"> SetNumberPartitions </a></td>
<td class="category-table-td"> Sets the number of partitions </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetThresholdRank_s"> GetThresholdRank </a></td>
<td class="category-table-td"> Returns the rank threshold </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetThresholdRank_s"> SetThresholdRank </a></td>
<td class="category-table-td"> Sets the rank threshold </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetThresholdSpurious_s"> GetThresholdSpurious </a></td>
<td class="category-table-td"> Returns the spurious threshold </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetThresholdSpurious_s"> SetThresholdSpurious </a></td>
<td class="category-table-td"> Sets the spurious threshold </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetBorthogonalization_s"> GetBorthogonalization </a></td>
<td class="category-table-td"> Returns the orthogonalization used in GD/JD solver </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetBorthogonalization_s"> SetBorthogonalization </a></td>
<td class="category-table-td"> Selects the orthogonalization used in GD/JD solver </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetDoubleExpansion_s"> GetDoubleExpansion </a></td>
<td class="category-table-td"> Returns the double expansion flag used in GD/JD solver </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetDoubleExpansion_s"> SetDoubleExpansion </a></td>
<td class="category-table-td"> Sets the double expansion flag used in GD/JD solver </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetInitialSize_s"> GetInitialSize </a></td>
<td class="category-table-td"> Returns the initial size used in GD/JD solver </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetInitialSize_s"> SetInitialSize </a></td>
<td class="category-table-td"> Sets the initial size used in GD/JD solver </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetKrylovRestart_s"> GetKrylovRestart </a></td>
<td class="category-table-td"> Returns the Krylov start flag used in GD/JD solver </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetKrylovRestart_s"> SetKrylovRestart </a></td>
<td class="category-table-td"> Sets the Krylov start flag used in GD/JD solver </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetRestartNumber_s"> GetRestartNumber </a></td>
<td class="category-table-td"> Returns the restart number </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetRestartNumber_s"> SetRestartNumber </a></td>
<td class="category-table-td"> Sets the restart number </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetRestartNumberAdd_s"> GetRestartNumberAdd </a></td>
<td class="category-table-td"> Returns the incremental restart number </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetRestartNumberAdd_s"> SetRestartNumberAdd </a></td>
<td class="category-table-td"> Sets the incremental restart number </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetNumberConvergedVectors_s"> GetNumberConvergedVectors </a></td>
<td class="category-table-td"> Returns the number of converged vectors </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetNumberConvergedVectors_s"> SetNumberConvergedVectors </a></td>
<td class="category-table-td"> Sets the number of converged vectors </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetNumberConvergedVectors_s"> GetNumberConvergedVectorsProjected </a></td>
<td class="category-table-td"> Returns the number of projected converged vectors </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetNumberConvergedVectors_s"> SetNumberConvergedVectorsProjected </a></td>
<td class="category-table-td"> Sets the number of projected converged vectors </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#UseNonLockingVariant_s"> UseNonLockingVariant </a></td>
<td class="category-table-td"> Returns true if the non-locking variant is used </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#UseNonLockingVariant_s"> SetNonLockingVariant </a></td>
<td class="category-table-td"> Sets the non-locking variant to use </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetRestartRatio_s"> GetRestartRatio </a></td>
<td class="category-table-td"> Returns the restart ratio </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetRestartRatio_s"> SetRestartRatio </a></td>
<td class="category-table-td"> Sets the restart ratio </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetMethod_s"> GetMethod </a></td>
<td class="category-table-td"> Returns the method to use in PRIMME solver </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetMethod_s"> SetMethod </a></td>
<td class="category-table-td"> Sets the method to use in PRIMME solver </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetShiftType_s"> GetShiftType </a></td>
<td class="category-table-td"> Returns the type of shift to use </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetShiftType_s"> SetShiftType </a></td>
<td class="category-table-td"> Sets the type of shift to use </td> </tr>


</table>

<p> The choice of eigensolver is made when calling function <a href="#GetEigenvaluesEigenvectors">GetEigenvaluesEigenvectors</a> by providing an optional argument. If this argument is not provided, default eigenvalue solver will be used (Arpack if available). </p>

<h2>Expert use</h2>

<p>If you want to use directly Arpack (through a reverse-communication interface), a simple class ArpackSolver has been written : </p>

\precode
// dimensions of the matrix
int m = 500, n = 100;
// example of matrix
Matrix<double, General, RowSparse> A(m, n);
// number of eigenvalues you want to compute
int nev = 4;
// number of Arnoldi vectors
int ncv = 20;
// maximum number of iterations
int maxit = 100;
// stopping criterion
double tol = 1e-6;
// solver (symmetric, non-symmetric)
string solver = "symmetric";
// Arpack mode (see Arpack documentation)
int mode = 1;
// eigenvalues desired (largest, smallest, etc)
string which = "LM";
// standard eigenvalue problem
char bmat = 'I';
// eigenvectors are also retrieved
char HowMny = 'A';
// true for displaying informations of Arpack
bool with_arpack_verbose = false;

// initialisation
ArpackSolver<double, double> S;
S.Init(n, nev, ncv, maxit, tol, solver_type, mode,
       which, bmat, HowMny, with_arpack_verbose);

Vector<double> x, y;

while (S.Continue())
  {    
    int ido = S.GetReverseCommunicationFlag();
    if (ido == 1 || ido == -1)
     {
       // matrix-vector product y = A*x
       // you can put your own matrix-vector product here
       x.SetData(n, S.GetFirstWorkVector());
       y.SetData(m, S.GetSecondWorkVector());
       Mlt(A, x, y);
       x.Nullify();
       y.Nullify();
     }
  }

bool success = S.Finish();
// displaying eigenvalues and eigenvectors
if (success)
  {
    for (int j = 0; j < S.GetConvergedNumber(); j++)
      {
        x.SetData(n, S.GetEigenVector(j));
        cout << "Eigenvalue " << S.GetEigenValue(j) << endl;
        cout << "Eigenvector " << x << endl;
        x.Nullify();
      }
  }
\endprecode

<p> An example is present in <code>test/program/arpack_test_svd.cpp</code>. Methods of ArpackSolver are listed below : </p>

<table class="category-table">
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#Init_arpack"> Init </a></td>
<td class="category-table-td"> Initialization of eigenvalue problem </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#CheckParameter"> CheckParameter </a></td>
<td class="category-table-td"> Checking input parameters </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#arpack_Clear"> Clear </a></td>
<td class="category-table-td"> Clears memory used by internal arrays </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#Allocate"> Allocate </a></td>
<td class="category-table-td"> allocation of internal arrays </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#Deallocate"> Deallocate </a></td>
<td class="category-table-td"> deallocation of internal arrays </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#SetArpackVerbose"> SetArpackVerbose </a></td>
<td class="category-table-td"> switches to verbose mode </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#ClearArpackVerbose"> ClearArpackVerbose </a></td>
<td class="category-table-td"> returns to silent mode </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetFirstWorkVector"> GetFirstWorkVector </a></td>
<td class="category-table-td"> returns pointer to first working vector </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetSecondWorkVector"> GetSecondWorkVector </a></td>
<td class="category-table-td"> returns pointer to second working vector </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetEigenVector"> GetEigenVector </a></td>
<td class="category-table-td"> returns pointer to i-th eigenvector </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetEigenValue"> GetEigenValue </a></td>
<td class="category-table-td"> returns i-th eigenvalue </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetReverseCommunicationFlag"> GetReverseCommunicationFlag </a></td>
<td class="category-table-td"> returns reverse-communication flag (ido parameter) </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetReverseCommunicationFlag"> SetReverseCommunicationFlag </a></td>
<td class="category-table-td"> modifies reverse-communication flag (ido parameter) </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetInfoFlag"> GetInfoFlag </a></td>
<td class="category-table-td"> returns info parameter (result of iterative algorithm) </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetInfoFlag"> SetInfoFlag </a></td>
<td class="category-table-td"> modifies info parameter </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetConvergedNumber"> GetConvergedNumber </a></td>
<td class="category-table-td"> returns the number of converged eigenvalues </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#Continue"> Continue </a></td>
<td class="category-table-td"> performs one step of the algorithm, returns true if the iterative algorithm has ended </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#Finish"> Finish </a></td>
<td class="category-table-td"> completes computation of eigenvalues and eigenvectors </td> </tr>
</table>



<p><br/> <br/></p>



<div class="separator"><a name="Init"></a></div>



<h3>Init</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void Init(int n);
</pre>


<p>This method is actually called by each eigenvalue solver before starting the research of eigenvalues.
 For example, it resets the number of iterations. This method should not be overloaded, neither called by the user. </p>


<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="InitMatrix"></a></div>



<h3>InitMatrix</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void InitMatrix(Matrix& K);
  void InitMatrix(Matrix& K, Matrix& M);
</pre>


<p>This method allows the initialization of pointers for the stiffness matrix and mass matrix.
 It is mandatory to call it when using SparseEigenProblem, DenseEigenProblem or VirtualEigenProblem. </p>

<h4>Example :</h4>
\precode

{

// declaration of the eigenproblem
DenseEigenProblem<double, double, General, RowMajor> var_eig;
Vector<double> eigen_values, eigen_imag;
Matrix<double> eigen_vec;

// you can set some parameters
var_eig.SetNbAskedEigenvalues(5);
var_eig.SetComputationalMode(var_eig.REGULAR_MODE);
var_eig.SetSpectrum(var_eig.LARGE_EIGENVALUES, 0);

// then you can construct the stiffness matrix
int n = 20;
Matrix<double, General, RowMajor> K(n, n);
K.FillRand();

// and you provide this matrix to the eigenproblem
// standard eigenvalue problem K x = lambda x
var_eig.InitMatrix(K);

// then you can call GetEigenvaluesEigenvectors
GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);

// for a generalized eigenvalue problem, provide M
Matrix<double, Symmetric, RowSymPacked> M(n, n);
M.SetIdentity();
// searching K x = lambda M x
var_eig.InitMatrix(K, M);

// then you can call GetEigenvaluesEigenvectors
GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);

// if the type of M is different from Matrix<double, Symmetric, RowSymPacked>
// and is Matrix<Tm, PropM, StorageM>
// use DenseEigenProblem<double, double, General, RowMajor, Tm, PropM, StorageM> var_eig;
}

{
// for a sparse eigenproblem, similar stuff
// declaration of the eigenproblem
SparseEigenProblem<double, Matrix<double, General, ArrayRowSparse> > var_eig;
Vector<double> eigen_values, eigen_imag;
Matrix<double> eigen_vec;

// you can set some parameters
var_eig.SetNbAskedEigenvalues(5);
var_eig.SetComputationalMode(var_eig.REGULAR_MODE);
var_eig.SetSpectrum(var_eig.LARGE_EIGENVALUES, 0);

// then you can construct the stiffness matrix
int n = 20;
Matrix<double, General, ArrayRowSparse> K(n, n);
K.FillRand();

// and you provide this matrix to the eigenproblem
// standard eigenvalue problem K x = lambda x
var_eig.InitMatrix(K);

// then you can call GetEigenvaluesEigenvectors
GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);

// for a generalized eigenvalue problem, provide M
Matrix<double, Symmetric, ArrayRowSymSparse> M(n, n);
M.SetIdentity();
// searching K x = lambda M x
var_eig.InitMatrix(K, M);

// then you can call GetEigenvaluesEigenvectors
GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);

// if the type of M is different from Matrix<double, Symmetric, ArrayRowSymSparse>
// and is Matrix<Tm, PropM, StorageM>
// use SparseEigenProblem<double, Matrix<double, General, ArrayRowSparse>,
//                                Matrix<Tm, PropM, StorageM> > var_eig;
}

{
  // matrix-free eigenproblem
  // stiffness matrix has type MyMatrixClass which derives from VirtualMatrix
  VirtualEigenProblem<double> var_eig;

  // you can set some parameters
  var_eig.SetNbAskedEigenvalues(5);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);
  var_eig.SetSpectrum(var_eig.LARGE_EIGENVALUES, 0);
 
  // then you can construct the stiffness matrix
  MyMatrixClass K;

  // and you provide this matrix to the eigenproblem
  // standard eigenvalue problem K x = lambda x
  var_eig.InitMatrix(K);

  // then you can call GetEigenvaluesEigenvectors
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);
}


\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="GetComputationalMode"></a></div>



<h3>GetComputationalMode, SetComputationalMode</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetComputationalMode(int);
  int GetComputationalMode();
</pre>


<p><b>SetComputationalMode</b> sets the computational mode to use for the research of eigenvalues and eigenvectors, whereas <b>GetComputationalMode</b> returns the computational mode used. The default computational mode is REGULAR_MODE. This mode is particularly well suited if you are looking for the largest eigenvalues of the matrix. However, it can induce a lot of iterations to converge if smallest eigenvalues are researched, and you can't compute eigenvalues closest to a given shift with that mode. The following available modes are (we put equivalent mode numbers in Arpack) : </p>

<ul>
<li> REGULAR_MODE : regular mode (1 for standard eigenproblem, 2 for generalized one) : K x = &mu; M x <br/>
In that mode, the mass matrix M must be real symmetric positive. <br/>
</li>

<li> SHIFTED_MODE : shifted mode (1 for standard eigenproblem, 3 for generalized one) : (K - &sigma; M)<sup>-1</sup> M x = &mu; x <br/>
In that mode, the mass matrix M must be real symmetric positive. <br/>
</li>

<li> IMAG_SHIFTED_MODE : shifted mode and use of imaginary part (4 for generalized eigenproblem, only for real unsymmetric matrices) : Imag{ (K- &sigma; M)<sup>-1</sup> M} x = &mu; x <br/>
In that mode, the mass matrix M must be real symmetric positive. <br/>
</li>

<li> INVERT_MODE : multiplication by inverse of M to have a standard eigenvalue problem (only for generalized eigenproblem) : (K - &sigma; M)<sup>-1</sup> M x = &mu; x <br/>
In that mode, the mass matrix M and stiffness matrix K can be any type of matrices. <br/> </li>

<li> BUCKLING_MODE : available for  real generalized symmetric eigenproblems (4 for Arpack) :
 (K - &sigma; M)<sup>-1</sup> K x = &mu; x <br/>
In that mode, the mass matrix M and stiffness matrix K must be real symmetric positive. <br/> </li>

<li> CAYLEY_MODE : available for real generalized symmetric eigenproblems (5 for Arpack) : (K - &sigma; M)<sup>-1</sup> (K + &sigma; M) x = &mu; x  <br/>
In that mode, the mass matrix M must be real symmetric positive, the stiffness matrix K must be real symmetric. <br/> </li>
</ul>

<p> INVERT_MODE is not a computational mode of Arpack, but rather a trick in order to use mode 1 for generalized eigenvalue problems. Similarly, if you inform that the mass matrix is diagonal, or if you ask to perform a Cholesky factorisation of the mass matrix, GetEigenvaluesEigenvectors will use mode 1 (a regular mode on K or (K - &sigma; M)<sup>-1</sup> M ) to compute eigenvalues. However for diagonal mass and Cholesky factorisation, the eigenproblem stays symmetric, while INVERT_MODE breaks the symmetry, and the computation should be less efficient. </p>

<h4>Example :</h4>
\precode

// declaration of the eigenproblem
SparseEigenProblem<double, Matrix<double, General, ArrayRowSparse> > var_eig;
Vector<double> eigen_values, eigen_imag;
Matrix<double> eigen_vec;

// you can set some parameters
var_eig.SetNbAskedEigenvalues(5);
var_eig.SetSpectrum(var_eig.LARGE_EIGENVALUES, 0);

// and choose the computational mode relevant with researched spectrum
var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

// then you can construct the stiffness matrix
int n = 20;
Matrix<double, General, ArrayRowSparse> K(n, n);
K.FillRand();

// and you provide this matrix to the eigenproblem
// standard eigenvalue problem K x = lambda x
var_eig.InitMatrix(K);

// then you can call GetEigenvaluesEigenvectors
GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);

// for a generalized eigenvalue problem, provide M
Matrix<double, Symmetric, ArrayRowSymSparse> M(n, n);
M.SetIdentity();
// searching K x = lambda M x
var_eig.InitMatrix(K, M);

// searching eigenvalues close to a shift
var_eig.SetTypeSpectrum(var_eig.CENTERED_EIGENVALUES, 0.5);
var_eig.SetComputationalMode(var_eig.SHIFTED_MODE);

// then you can call GetEigenvaluesEigenvectors
GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="GetCommunicator"></a></div>



<h3>GetCommunicator</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  const MPI::Comm& GetCommunicator() const;
  void SetCommunicator(const MPI::Comm&);
</pre>


<p>The method SetCommunicator sets the MPI communicator (that will be used for Parpack). The method GetCommunicator
 returns the MPI communicator associated with the eigenvalue problem. Soon an example of parallel computation of eigenvalues will be given. </p>



<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="GetNbAskedEigenvalues"></a></div>



<h3>GetNbAskedEigenvalues</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetNbAskedEigenvalues(int nev);
  int GetNbAskedEigenvalues();
</pre>


<p><b>SetNbAskedEigenvalues</b> sets the number of converged eigenvalues you desire to know, whereas <b>GetNbAskedEigenvalues</b> returns the number of desired eigenvalues. This method is mandatory since the default number of eigenvalues is equal to 0. </p>

<h4>Example :</h4>
\precode

// declaration of the eigenproblem
SparseEigenProblem<double, Matrix<double, General, ArrayRowSparse> > var_eig;
Vector<double> eigen_values, eigen_imag;
Matrix<double> eigen_vec;

// you can set some parameters
var_eig.SetNbAskedEigenvalues(5);
var_eig.SetSpectrum(var_eig.LARGE_EIGENVALUES, 0);

// and choose the computational mode relevant with researched spectrum
var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

// then you can construct the stiffness matrix
int n = 20;
Matrix<double, General, ArrayRowSparse> K(n, n);
K.FillRand();

// and you provide this matrix to the eigenproblem
// standard eigenvalue problem K x = lambda x
var_eig.InitMatrix(K);

// then you can call GetEigenvaluesEigenvectors
GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="GetNbAdditionalEigenvalues"></a></div>



<h3>GetNbAdditionalEigenvalues, SetNbAdditionalEigenvalues</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetNbAdditionalEigenvalues(int nev);
  int GetNbAdditionalEigenvalues();
</pre>


<p><b>SetNbAdditionalEigenvalues</b> sets the number of additional eigenvalues to avoid problems in Arpack, whereas <b>GetNbAdditionalEigenvalues</b> returns the number of additional eigenvalues. Usually Arpack works correctly, but if you see that the recover of eigenvalues generates a segmentation fault, you can provide additional eigenvalues, it may fix the problem.. </p>

<h4>Example :</h4>
\precode

// declaration of the eigenproblem
SparseEigenProblem<double, Matrix<double, General, ArrayRowSparse> > var_eig;
Vector<double> eigen_values, eigen_imag;
Matrix<double> eigen_vec;

// you can set some parameters
var_eig.SetNbAskedEigenvalues(5);
var_eig.SetNbAdditionalEigenvalues(1);
var_eig.SetSpectrum(var_eig.LARGE_EIGENVALUES, 0);

// and choose the computational mode relevant with researched spectrum
var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

// then you can construct the stiffness matrix
int n = 20;
Matrix<double, General, ArrayRowSparse> K(n, n);
K.FillRand();

// and you provide this matrix to the eigenproblem
// standard eigenvalue problem K x = lambda x
var_eig.InitMatrix(K);

// then you can call GetEigenvaluesEigenvectors
GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="GetAnasaziParameters"></a></div>



<h3>GetAnasaziParameters</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  AnasaziParam& GetAnasaziParameters();
</pre>


<p> This method returns the parameters associated with Anasazi solver. </p>

<h4>Example :</h4>
\precode

// declaration of the eigenproblem
SparseEigenProblem<double, Matrix<double, General, ArrayRowSparse> > var_eig;
Vector<double> eigen_values, eigen_imag;
Matrix<double> eigen_vec;

// you can set some parameters
var_eig.SetNbAskedEigenvalues(5);
var_eig.SetSpectrum(var_eig.LARGE_EIGENVALUES, 0);

// and also parameters specific to Anasazi
AnasaziParam& param = var_eig.GetAnasaziParameters();
param.SetEigensolverType(param.SOLVER_BKS);

// and choose the computational mode relevant with researched spectrum
var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

// then you can construct the stiffness matrix
int n = 20;
Matrix<double, General, ArrayRowSparse> K(n, n);
K.FillRand();

// and you provide this matrix to the eigenproblem
// standard eigenvalue problem K x = lambda x
var_eig.InitMatrix(K);

// then you can call GetEigenvaluesEigenvectors
GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec, TypeEigenvalueSolver::ANASAZI);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>


<div class="separator"><a name="GetSlepcParameters"></a></div>



<h3>GetSlepcParameters</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  SlepcParam& GetSlepcParameters();
</pre>


<p> This method returns the parameters associated with SLEPc solver. </p>

<h4>Example :</h4>
\precode

// declaration of the eigenproblem
SparseEigenProblem<double, Matrix<double, General, ArrayRowSparse> > var_eig;
Vector<double> eigen_values, eigen_imag;
Matrix<double> eigen_vec;

// you can set some parameters
var_eig.SetNbAskedEigenvalues(5);
var_eig.SetSpectrum(var_eig.LARGE_EIGENVALUES, 0);

// and also parameters specific to SLEPc
SlepcParam& param = var_eig.GetSlepcParameters();
param.SetEigensolverType(param.ARPACK);

// and choose the computational mode relevant with researched spectrum
var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

// then you can construct the stiffness matrix
int n = 20;
Matrix<double, General, ArrayRowSparse> K(n, n);
K.FillRand();

// and you provide this matrix to the eigenproblem
// standard eigenvalue problem K x = lambda x
var_eig.InitMatrix(K);

// then you can call GetEigenvaluesEigenvectors
GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec, TypeEigenvalueSolver::ANASAZI);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="GetNbBlocks"></a></div>



<h3>GetNbBlocks, SetNbBlocks</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetNbBlocks(int n);
  int GetNbBlocks();
</pre>


<p><b>SetNbBlocks</b> sets the number of blocks to use in Anasazi, whereas <b>GetNbBlocks</b> returns the number of blocks.  </p>

<h4>Example :</h4>

\precode

  SparseEigenProblem<T, MatrixK, MatrixM> var_eig;

  var_eig.SetStoppingCriterion(1e-14);
  var_eig.SetNbMaximumIterations(20000);
  var_eig.SetNbAskedEigenvalues(nb_eigenval);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

  var_eig.InitMatrix(K, M);

  AnasaziParam& param = var_eig.GetAnasaziParameters();
  param.SetEigensolverType(param.SOLVER_BKS);

  param.SetNbMaximumRestarts(200);
  param.SetNbBlocks(10);
  var_eig.SetNbArnoldiVectors(nb_eigenval+1);

  // Large eigenvalues
  var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0, var_eig.SORTED_MODULUS);
  
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);
  DISP(lambda); DISP(lambda_imag);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="GetNbMaximumRestarts"></a></div>



<h3>GetNbMaximumRestarts, SetNbMaximumRestarts</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetNbMaximumRestarts(int n);
  int GetNbMaximumRestarts();
</pre>


<p><b>SetNbMaximumRestarts</b> sets the maximal number of restarts allowed in Anasazi, whereas <b>GetNbMaximumRestarts</b> returns this number.  </p>
			       
<h4>Example :</h4>

\precode

  SparseEigenProblem<T, MatrixK, MatrixM> var_eig;

  var_eig.SetStoppingCriterion(1e-14);
  var_eig.SetNbMaximumIterations(20000);
  var_eig.SetNbAskedEigenvalues(nb_eigenval);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

  var_eig.InitMatrix(K, M);

  AnasaziParam& param = var_eig.GetAnasaziParameters();
  param.SetEigensolverType(param.SOLVER_BKS);

  param.SetNbMaximumRestarts(200);
  param.SetNbBlocks(10);
  var_eig.SetNbArnoldiVectors(nb_eigenval+1);

  // Large eigenvalues
  var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0, var_eig.SORTED_MODULUS);
  
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);
  DISP(lambda); DISP(lambda_imag);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="GetOrthoManager"></a></div>



<h3>GetOrthoManager</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
    int GetOrthoManager();
</pre>


<p>This method returns the orthogonal manager to use in Anasazi solvers.  </p>
			       

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="GetEigensolverType"></a></div>



<h3>GetEigensolverType, SetEigensolverType</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetEigensolverType(int type);
  int GetEigensolverType();
</pre>


<p><b>SetEigensolverType</b> sets the type of eigensolver to use in Anasazi, whereas <b>GetEigensolverType</b> returns this number. You can choose between SOLVER_LOBPCG, SOLVER_BKS and SOLVER_BD.  </p>
			       
<h4>Example :</h4>

\precode

  SparseEigenProblem<T, MatrixK, MatrixM> var_eig;

  var_eig.SetStoppingCriterion(1e-14);
  var_eig.SetNbMaximumIterations(20000);
  var_eig.SetNbAskedEigenvalues(nb_eigenval);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

  var_eig.InitMatrix(K, M);
  var_eig.SetNbArnoldiVectors(nb_eigenval+1);

  AnasaziParam& param = var_eig.GetAnasaziParameters();
  param.SetEigensolverType(param.SOLVER_BKS);
  param.SetNbBlocks(10);
  param.SetNbMaximumRestarts(200);	  

  // Large eigenvalues
  var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0, var_eig.SORTED_MODULUS);
  
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec, TypeEigenvalueSolver::ANASAZI);
  DISP(lambda); DISP(lambda_imag);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="GetTypeSpectrum"></a></div>



<h3>GetTypeSpectrum, SetTypeSpectrum</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetTypeSpectrum(int type, T sigma);
  void SetTypeSpectrum(int type, T sigma, int type_sort);
  int GetTypeSpectrum();
</pre>


<p><b>SetTypeSpectrum</b> sets the part of the spectrum you desire to know, whereas <b>GetTypeSpectrum</b> returns the type of researched spectrum. You can ask LARGE_EIGENVALUES, SMALL_EIGENVALUES and CENTERED_EIGENVALUES, to research largest eigenvalues, smallest eigenvalues and eigenvalues closest to the shift sigma. If you search the largest or smallest eigenvalues, the shift won't be used, and you can only use REGULAR_MODE. In the case of small eigenvalues, this mode may induce a high number of iterations, it can be a good idea to search eigenvalues close to a small value. type_sort can be used to specify how values are sorted, you can search largest eigenvalues by their modulus, real part or imaginary part (SORTED_MODULUS, SORTED_REAL and SORTED_IMAG). SORTED_MODULUS is the default sorting strategy. </p>

<h4>Example :</h4>
\precode

// declaration of the eigenproblem
SparseEigenProblem<double, Matrix<double, General, ArrayRowSparse> > var_eig;
Vector<double> eigen_values, eigen_imag;
Matrix<double> eigen_vec;

// you can set some parameters
var_eig.SetNbAskedEigenvalues(5);
var_eig.SetSpectrum(var_eig.LARGE_EIGENVALUES, 0);

// for eigenvalues closest to 0.25+0.3i
var_eig.SetSpectrum(var_eig.CENTERED_EIGENVALUES, complex<double>(0.25, 0.3), SORTED_IMAG);

if (var_eig.GetTypeSpectrum() != var_eig.CENTERED_EIGENVALUES)
  cout << "not possible" << endl;

// and choose the computational mode relevant with researched spectrum
var_eig.SetComputationalMode(var_eig.SHIFTED_MODE);

// then you can construct the stiffness matrix
int n = 20;
Matrix<double, General, ArrayRowSparse> K(n, n);
K.FillRand();

// and you provide this matrix to the eigenproblem
// standard eigenvalue problem K x = lambda x
var_eig.InitMatrix(K);

// then you can call GetEigenvaluesEigenvectors
GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="GetTypeSorting"></a></div>



<h3>GetTypeSorting</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int GetTypeSorting();
</pre>


<p>This methods returns the sorting strategy used (SORTED_MODULUS, SORTED_REAL or SORTED_IMAG). </p>

<h4>Example :</h4>
\precode

// declaration of the eigenproblem
SparseEigenProblem<double, Matrix<double, General, ArrayRowSparse> > var_eig;
Vector<double> eigen_values, eigen_imag;
Matrix<double> eigen_vec;

// you can set some parameters
var_eig.SetNbAskedEigenvalues(5);
var_eig.SetSpectrum(var_eig.LARGE_EIGENVALUES, 0);

if (var_eig.GetTypeSorting() != var_eig.SORTED_MODULUS)
  cout << "not possible" << endl;

// and choose the computational mode relevant with researched spectrum
var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

// then you can construct the stiffness matrix
int n = 20;
Matrix<double, General, ArrayRowSparse> K(n, n);
K.FillRand();

// and you provide this matrix to the eigenproblem
// standard eigenvalue problem K x = lambda x
var_eig.InitMatrix(K);

// then you can call GetEigenvaluesEigenvectors
GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);

\endprecode



<div class="separator"><a name="GetShiftValue"></a></div>



<h3>GetShiftValue, GetImagShiftValue</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  T GetShiftValue();
  T GetImagShiftValue();
</pre>


<p>This methods returns the shift. For real unsymmetric matrices, you can also retrieve imaginary part of the shift </p>

<h4>Example :</h4>
\precode

// declaration of the eigenproblem
SparseEigenProblem<double, Matrix<double, General, ArrayRowSparse> > var_eig;
Vector<double> eigen_values, eigen_imag;
Matrix<double> eigen_vec;

// you can set some parameters
var_eig.SetNbAskedEigenvalues(5);

// for eigenvalues closest to 0.25+0.3i
var_eig.SetSpectrum(var_eig.CENTERED_EIGENVALUES, complex<double>(0.25, 0.3), SORTED_IMAG);

// shift_r = 0.25 and shift_i = 0.3
double shift_r = var_eig.GetShiftValue();
double shift_i = var_eig.GetImagShiftValue();

\endprecode



<div class="separator"><a name="GetComplexShift"></a></div>



<h3>GetComplexShift</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void GetComplexShift(T sr, T si, T& s)
</pre>


<p>This methods sets s = sr + I si if sr and si are real, and s = sr if sr and si are complex. This method should not be called in regular use.</p>



<div class="separator"><a name="SetIntervalSpectrum"></a></div>



<h3>SetIntervalSpectrum</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetIntervalSpectrum(double Lmin, double Lmax);
  double GetLowerBoundInterval();
  double GetUpperBoundInterval();
</pre>


<p>The method <b>SetIntervalSpectrum</b> sets the interval where eigenvalues are searched (for a symmetric matrix, and Feast eigensolver).</p>

<h4>Example :</h4>

\precode

  SparseEigenProblem<T, MatrixK, MatrixM> var_eig;
  
  // first, we test the case without the mass matrix M
  
  var_eig.SetStoppingCriterion(1e-12);
  var_eig.SetNbAskedEigenvalues(nb_eigenval);  
  var_eig.InitMatrix(K);  
  
  // eigenvalues are searched within a given interval
  var_eig.SetIntervalSpectrum(-1.7, -1.0);
  
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);

\endprecode



<div class="separator"><a name="SetCholeskyFactoForMass"></a></div>




<h3>SetCholeskyFactoForMass, UseCholeskyFactoForMass</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetCholeskyFactoForMass(bool);
  void SetCholeskyFactoForMass();
  bool UseCholeskyFactoForMass();
</pre>


<p>When solving generalized eigenvalue problems K x = &lambda; M x, if K and M are symmetric, it can be attractive to perform a Cholesky factorization of M = L L<sup>T</sup>, and consider the standard problem L<sup>-1</sup> K L<sup>-T</sup> x = &lambda; x. If you want to use that strategy, <b>SetCholeskyFactoForMass</b> has to be called. <b>UseCholeskyFactoForMass</b> returns true if this strategy is used. </p>

<h4>Example :</h4>
\precode

// declaration of the eigenproblem
SparseEigenProblem<double, Matrix<double, General, ArrayRowSparse> > var_eig;
Vector<double> eigen_values, eigen_imag;
Matrix<double> eigen_vec;

// you can set some parameters
var_eig.SetNbAskedEigenvalues(5);
var_eig.SetSpectrum(var_eig.CENTERED_EIGENVALUES, 0.4);

// then use Cholesky factorization
var_eig.SetCholeskyFactoForMass();
if (var_eig.UseCholekyFactoForMass())
    cout << "Searching eigenvalues of L^-1  K L^-T" << endl;

// if you want to cancel that, or solve another problem without Cholesky
var_eig.SetCholeskyFactoForMass(false);

// then declare a generalized problem
var_eig.InitMatrix(K, M);

\endprecode



<div class="separator"><a name="SetDiagonalMass"></a></div>




<h3>SetDiagonalMass, DiagonalMass</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetDiagonalMass();
  void SetDiagonalMass(bool);
  bool DiagonalMass();
</pre>


<p>When solving generalized eigenvalue problems K x = &lambda; M x, if K and M are symmetric and M diagonal, it can be attractive to consider the standard problem M<sup>-1/2</sup> K M<sup>-1/2</sup> x = &lambda; x. If you want to use that strategy, <b>SetDiagonalMass</b> has to be called. <b>DiagonalMass</b> returns true if this strategy is used. </p>

<h4>Example :</h4>
\precode

// declaration of the eigenproblem
SparseEigenProblem<double, Matrix<double, General, ArrayRowSparse> > var_eig;
Vector<double> eigen_values, eigen_imag;
Matrix<double> eigen_vec;

// you can set some parameters
var_eig.SetNbAskedEigenvalues(5);
var_eig.SetSpectrum(var_eig.CENTERED_EIGENVALUES, 0.4);

// then inform that mass matrix is diagonal
var_eig.SetDiagonalMass();
if (var_eig.DiagonalMass())
    cout << "Searching eigenvalues of M^-1/2  K M^-1/2" << endl;

// if you want to cancel that, or solve another problem without diagonal mass
var_eig.SetDiagonalMass(false);

// then declare a generalized problem
var_eig.InitMatrix(K, M);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="SetStoppingCriterion"></a></div>




<h3>SetStoppingCriterion, GetStoppingCriterion</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetStoppingCriterion(double);
  double GetStoppingCriterion();
</pre>


<p>With those methods, you can modify and retrieve the stopping criterion used by the iterative algorithm. The default value is equal to 1e-6. </p>

<h4>Example :</h4>
\precode

// declaration of the eigenproblem
SparseEigenProblem<double, Matrix<double, General, ArrayRowSparse> > var_eig;
Vector<double> eigen_values, eigen_imag;
Matrix<double> eigen_vec;

// you can set some parameters
var_eig.SetNbAskedEigenvalues(5);
var_eig.SetStoppingCriterion(1e-12);
var_eig.SetSpectrum(var_eig.CENTERED_EIGENVALUES, 0.4);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="SetNbMaximumIterations"></a></div>




<h3>SetNbMaximumIterations, GetNbMaximumIterations</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetNbMaximumIterations(int);
  int GetNbMaximumIterations();
</pre>


<p>With those methods, you can modify and retrieve the maximal number of iterations completed by the iterative algorithm. If the iterative algorithm spends more iterations, it is stopped. The default value is equal to 1000.  </p>

<h4>Example :</h4>
\precode

// declaration of the eigenproblem
SparseEigenProblem<double, Matrix<double, General, ArrayRowSparse> > var_eig;
Vector<double> eigen_values, eigen_imag;
Matrix<double> eigen_vec;

// you can set some parameters
var_eig.SetNbAskedEigenvalues(5);
var_eig.SetStoppingCriterion(1e-12);
var_eig.SetNbMaximumIterations(10000);
var_eig.SetSpectrum(var_eig.CENTERED_EIGENVALUES, 0.4);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="GetNbMatrixVectorProducts"></a></div>



<h3>GetNbMatrixVectorProducts</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int GetNbMatrixVectorProducts();
</pre>


<p>This method returns the number of matrix vector products (for shifted mode, it would be the number of resolutions by operator K - sigma M) performed by the iterative process.  </p>

<h4>Example :</h4>
\precode

// declaration of the eigenproblem
VirtualEigenProblem<double> var_eig;
Vector<double> eigen_values, eigen_imag;
Matrix<double> eigen_vec;

// you can set some parameters
var_eig.SetNbAskedEigenvalues(5);
var_eig.SetSpectrum(var_eig.LARGE_EIGENVALUES, 0.0);

var_eig.InitMatrix(K);

// research of eigenvalues
GetEigenvaluesEigenvectors(var_eig, eigen_values, eigen_imag, eigen_vec);

// then displaying the number of matrix vector products performed :
cout << "Number of times K x has been done : " << var_eig.GetNbMatrixVectorProducts() << endl;

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="GetNbArnoldiVectors"></a></div>



<h3>GetNbArnoldiVectors, SetNbArnoldiVectors</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int GetNbArnoldiVectors();
  void SetNbArnoldiVectors(int n);
</pre>


<p>You can modify and retrieve the number of Arnoldi vectors used by the iterative algorithm. It can be a good idea to increase the number of Arnolid vectors in order to improve the convergence. By default, the number of Arnoldi vectors is set to 2 nev + 2  where nev is the number of asked eigenvalues.  </p>

<h4>Example :</h4>
\precode

// declaration of the eigenproblem
VirtualEigenProblem<double> var_eig;
Vector<double> eigen_values, eigen_imag;
Matrix<double> eigen_vec;

// you can set some parameters
var_eig.SetNbAskedEigenvalues(5);
var_eig.SetSpectrum(var_eig.LARGE_EIGENVALUES, 0.0);

// and require a larger number of Arnoldi vectors
var_eig.SetNbArnoldiVectors(20);

var_eig.InitMatrix(K);

// research of eigenvalues
GetEigenvaluesEigenvectors(var_eig, eigen_values, eigen_imag, eigen_vec);

cout << "Number of Arnoldi vectors used by simulation" << var_eig.GetNbArnoldiVectors() << endl;

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="GetM"></a></div>



<h3>GetM, GetN</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int GetM();
  int GetN();
</pre>


<p><b>GetM</b> returns the number of rows of the stiffness matrix, while <b>GetN</b> returns the number of columns.  </p>

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="GetPrintLevel"></a></div>



<h3>GetPrintLevel</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  int GetPrintLevel();
  void SetPrintLevel(int n);
</pre>


<p>By increasing print level, more messages should be displayed on the standard output. </p>

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="IncrementProdMatVect"></a></div>



<h3>IncrementProdMatVect</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
void IncrementProdMatVect();
</pre>


<p>This method is used internally to increment the variable containing the number of matrix vector products. It should not be called by the user. </p>

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="PrintErrorInit"></a></div>



<h3>PrintErrorInit</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
void PrintErrorInit();
</pre>


<p>This method is used internally to display an error message and stop the program if InitMatrix has not been called. </p>

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="IsSymmetricProblem"></a></div>



<h3>IsSymmetricProblem</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
bool IsSymmetricProblem();
</pre>


<p>This method returns true if the eigenvalue problem involves symmetric mass and stiffness matrices. </p>

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="IsHermitianProblem"></a></div>



<h3>IsHermitianProblem</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
bool IsHermitianProblem();
</pre>


<p>This method returns true if the eigenvalue problem involves a symmetric mass matrix and an hermitian stiffness matrix. </p>

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="FactorizeDiagonalMass"></a></div>



<h3>FactorizeDiagonalMass</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
void FactorizeDiagonalMass(Vector&);
</pre>


<p>This method computes the square root of diagonal mass matrix. It is a virtual method that can be overloaded if you define your own eigenproblem.  </p>

<h4>Example:</h4>

\precode
template<class T, class MatStiff, class MatMass>
class MyOwnEigenProblem : public VirtualEigenProblem<T, typename MatStiff::entry_type, typename MatMass::entry_type>
{
  protected:
    // you can add members to handle diagonal mass matrix
    // for example, you could consider a diagonal with only
    // two coefficient D = [alpha I, 0; 0, beta I]
    double alpha, beta, sqrt_alpha, sqrt_beta;

  public :

  // computation of diagonal mass matrix
  void ComputeDiagonalMass()
  {
     // you may use Mh
     if (this->Mh != NULL)
       {
         MatMass& M = dynamic_cast<MatMass&>(*this->Mh);
         alpha = M(0, 0);
	 beta = M(1, 1);
       }
     else
       {
         // or not
         alpha = 1.5; beta = 3.0;
       }
   }
									      }

  // computation of sqrt(D)
  void FactorizeDiagonalMass()
  {
     sqrt_alpha = sqrt(alpha);
     sqrt_beta = sqrt(beta);
  }

  // sqrt(D) can be written in an output vector
  void GetSqrtDiagonal(Vector<T>& D)
  {
    D.Reallocate(this->n_);
    for (int i = 0; i < this->n_; i += 2)
      {
        D(i) = sqrt_alpha;
	D(i+1) = sqrt_beta;
      }
  }

  // application of sqrt(D)
  void MltSqrtDiagonalMass(Vector<double>& X)
  {
    for (int i = 0; i < X.GetM(); i+=2)
      {
        X(i) *= sqrt_alpha;
	X(i+1) *= sqrt_beta;
      }
  }

  // application of 1/sqrt(D)
  void MltInvSqrtDiagonalMass(Vector<double>& X)
  {
    for (int i = 0; i < X.GetM(); i+=2)
      {
         X(i) /= sqrt_alpha;
	 X(i+1) /= sqrt_beta;
      }
   }

};


int main()
{

// then you can use this class :
MyOwnEigenProblem<double, MyStiffMatrix, MyMassMatrix> var_eig;
Vector<double> lambda, lambda_imag;
Matrix<double> eigen_vec;

// set some parameters
var_eig.SetNbAskedEigenvalues(5);
// specify that mass matrix is actually diagonal
var_eig.SetDiagonalMass();

// initialized pointers to matrices
var_eig.InitMatrix(K, M);

// then call computation of eigenvalues
GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);

}
\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="MltSqrtDiagonalMass"></a></div>



<h3>MltSqrtDiagonalMass, MltInvSqrtDiagonalMass</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
void MltSqrtDiagonalMass(Vector&);
void MltInvSqrtDiagonalMass(Vector&);
</pre>


<p>These methods apply M<sup>1/2</sup> or M<sup>-1/2</sup> to a given vector. It is a virtual method that can be overloaded if you define your own eigenproblem. You can look at the example given in the method <a href="#FactorizeDiagonalMass">FactorizeDiagonalMass</a>. </p>


<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="GetSqrtDiagonal"></a></div>



<h3>GetSqrtDiagonal</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
void GetSqrtDiagonal(Vector& D);
</pre>


<p>This method fills sqrt(M) in the vector D when M is the mass matrix and has been declared as diagonal. It is a virtual method that can be overloaded if you define your own eigenproblem. You can look at the example given in the method <a href="#FactorizeDiagonalMass">FactorizeDiagonalMass</a>. </p>


<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="ComputeDiagonalMass"></a></div>



<h3>ComputeDiagonalMass</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
void ComputeDiagonalMass();
</pre>


<p>This method computes the diagonal of mass matrix. It is used internally, it should not be called directly by the user. However, if you derive a class for your own eigenproblem, and you want to change how diagonal mass matrices are handled, you can overload this method. You can look at the example given in the method <a href="#FactorizeDiagonalMass">FactorizeDiagonalMass</a>. </p>

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="ComputeMassForCholesky"></a></div>



<h3>ComputeMassForCholesky</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
void ComputeMassForCholesky();
</pre>


<p>This method is assumed to compute the mass matrix when a Cholesky factorisation is required. It can differ from the computation of the mass matrix when a matrix vector product is required, since that in that latter case, the matrix may be not stored. This method is used internally and should not be called directly by the user. However, if you need to change how Cholesky factorisation is handled, you can overload this function as shown in the example of member function <a href="#FactorizeCholeskyMass">FactorizeCholeskyMass</a>. </p>

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="ComputeMassMatrix"></a></div>



<h3>ComputeMassMatrix</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
void ComputeMassMatrix();
</pre>


<p>This method is assumed to compute the mass matrix when a matrix vector product is required. This method is called internally, and the user should not call it directly. However, if you have your own storage and matrix-vector product with mass matrix, you can overload this function as shown in the example of member function <a href="#MltMass">MltMass</a>. </p>

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="MltMass"></a></div>



<h3>MltMass</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
void MltMass(const Vector& X, Vector& Y);
</pre>


<p>This method is assumed to compute Y = M X, where M is the mass matrix. This method is called internally, and the user should not call it directly. However, if you have your own storage and matrix-vector product with mass matrix, you can overload this function as shown below : </p>

<h4>Example :</h4>
\precode
template<class T, class MatStiff, class MatMass>
class MyOwnEigenProblem : public VirtualEigenProblem<T, typename MatStiff::entry_type, typename MatMass::entry_type>
{
  protected:
  // you can add members to handle mass matrix
  double coef;

  public :
  
  // computation of mass matrix
  void ComputeMassMatrix()
  {
    // here you compute all you need to perform matrix-vector products
    // with the mass matrix
    coef = 2.5;
  }  

  // application of mass matrix (tridiagonal here)
  void MltMass(const Vector<T>& X, Vector<T>& Y)
  {
    int n = X.GetM();
    Y(0) = 4.0*X(0) + X(1);
    Y(n-1) = 4.0*X(n-1) + X(n-2);
    for (int i = 1; i < n-1; i++)
      Y(i) = 4.0*X(i) + X(i-1) + X(i+1);
    
    Mlt(coef, Y);
  }
  
};

int main()
{

// then you can use this class :
MyOwnEigenProblem<double, MyStiffMatrix, MyMassMatrix> var_eig;
Vector<double> lambda, lambda_imag;
Matrix<double> eigen_vec;

// set some parameters
var_eig.SetNbAskedEigenvalues(5);

// initializing pointers to matrices
var_eig.InitMatrix(K, M);

// then calling computation of eigenvalues
GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);

} 
\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="ComputeStiffnessMatrix"></a></div>



<h3>ComputeStiffnessMatrix</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
void ComputeStiffnessMatrix();
void ComputeStiffnessMatrix(const T& a, const T& b);
</pre>


<p>This method is assumed to compute the stiffness matrix when a matrix vector product is required. This method is called internally, and the user should not call it directly. However, if you have your own storage and matrix-vector product with stiffness matrix, you can overload this function as shown in the example of member function <a href="#MltStiffness">MltStiffness</a>. One other option is to write your own class for stiffness matrix inheriting from the class VirtualMatrix and overload the methods MltVector and MltAddVector as shown in the section "Advanced Use", then you can use VirtualEigenProblem class. Nevertheless, this class is not appropriate for shift-invert mode (only regular mode can be used). </p>

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="MltStiffness"></a></div>



<h3>MltStiffness</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
void MltStiffness(const Vector& X, Vector& Y);
void MltStiffness(const T& a, const T& b, const Vector& X, Vector& Y);
</pre>


<p>This method is assumed to compute Y = K X (or Y = (a M + b K) X ), where M is the mass matrix and K the stiffness matrix. This method is called internally, and the user should not call it directly. We assume here that either we need to compute Y = K X, either Y = (a M + b K) X (depending on the computational mode), but we do not need to perform both operations. However, if you have your own storage and matrix-vector product with stiffness matrix, you can overload this function as shown below :  </p>

<h4>Example :</h4>
\precode
template<class T, class MatStiff, class MatMass>
class MyOwnEigenProblem : public VirtualEigenProblem<T, typename MatStiff::entry_type, typename MatMass::entry_type>
{
  protected:
  // you can add members to handle stiffness matrix
  double alpha, beta, gamma;

  public :
  
  // computation of stiffness matrix
  void ComputeStiffnessMatrix()
  {
    // you compute here all you need 
    alpha = 1.4;
    beta = 2.5;
    gamma = 0.8;
  }

  // computation of a M + b K
  void ComputeStiffnessMatrix(const T& a, const T& b)
  {
    // we consider that M = I
    alpha = 1.4*b;
    beta = a + 2.5*b;
    gamma = 0.8*b;
  }
  

  // application of stiffness matrix (tridiagonal here)
  void MltStiffness(const Vector<T>& X, Vector<T>& Y)
  {
    int n = X.GetM();
    Y(0) = beta*X(0) + gamma*X(1);
    Y(n-1) = beta*X(n-1) + alpha*X(n-2);
    for (int i = 1; i < n-1; i++)
      Y(i) = beta*X(i) + alpha*X(i-1) + gamma*X(i+1);
    
  }


  // computation of Y = (a M + b K) X
  void MltStiffness(const T& a, const T& b, const Vector<T>& X, Vector<T>& Y)
  {
     // we use the fact that either we have to compute Y = K X 
     // either Y = (a M + b K) X, but not both
     MltStiffness(X, Y);
  }
  
};

int main()
{

// then you can use this class :
MyOwnEigenProblem<double, MyStiffMatrix, MyMassMatrix> var_eig;
Vector<double> lambda, lambda_imag;
Matrix<double> eigen_vec;

// set some parameters
var_eig.SetNbAskedEigenvalues(5);

// initializing pointers to matrices
var_eig.InitMatrix(K, M);

// then calling computation of eigenvalues
GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);

} 
\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="ComputeAndFactorizeStiffnessMatrix"></a></div>



<h3>ComputeAndFactorizeStiffnessMatrix</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
void ComputeAndFactorizeStiffnessMatrix(const T& a, const T& b, int real_p = COMPLEX_PART);
void ComputeAndFactorizeStiffnessMatrix(const complex<T>& a, const complex<T>& b, int real_p = COMPLEX_PART);
</pre>


<p>This method is assumed to compute matrix a M + b K and factorize this matrix. If this matrix is solved by an iterative algorithm, the factorization can consist of constructing a preconditioning. This method is called internally, and the user should not call it directly. However, if you have your own procedure to solve linear system (a M + b K) y = x , you can overload this function as shown in the example of member function <a href="#ComputeSolution">ComputeSolution</a>. For real unsymmetric matrices, coefficients a and b can be complex and we require complex part, real part or imaginary part of the factorization of a M + b K. </p>

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="ComputeSolution"></a></div>



<h3>ComputeSolution</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
void ComputeSolution(const Vector& X, Vector& Y);
void ComputeSolution(const SeldonTranspose&, const Vector& X, Vector& Y);
</pre>


<p>This method is assumed to solve (a M + b K) Y = X, where M is the mass matrix and K the stiffness matrix. Coefficients a and b have been given when calling the function ComputeAndFactorizeStiffnessMatrix. This method is called internally, and the user should not call it directly. However, if you have your own procedure to solver the linear system (a M + b K) y = x , you can overload this function as shown below :  </p>

<h4>Example :</h4>
\precode
template<class T, class MatStiff, class MatMass>
class MyOwnEigenProblem : public VirtualEigenProblem<T, typename MatStiff::entry_type, typename MatMass::entry_type>,
       public VirtualMatrix<T>, public Preconditioner_Base<T>
{
  protected:
  // you can add members to handle factorization
  double alpha, beta;
  Vector<double> precond;

  public :
  
  // computation of  a M + b K and factorization
  void ComputeAndFactorizeStiffnessMatrix(const T& a, const T& b, int real_p = COMPLEX_PART)
  {
    const MatMass& M = dynamic_cast<MatMass&>(*this->Mh);
    const MatStiff& K = dynamic_cast<MatStiff&>(*this->Kh);
    alpha = a;
    beta = b;
    // iterative process, constructing preconditioning
    // example of diagonal preconditioning
    precond.Reallocate(this->n_);
    for (int i = 0; i < this->n_; i++)
      precond(i) = 1.0 / (a*M(i, i) + b*K(i, i));
  }  

  // resolution of (a M + b K) y = x
  void ComputeSolution(const Vector<T>& X, Vector<T>& Y)
  {
    // use of conjugate gradient to solve the linear system
    Iteration<double> iter(10000, 1e-12); 
    Cg(*this, Y, X, *this, iter);
  }

  void MltVector(const Vector<T>& x, Vector<T>& y)
  {  
    Mlt(*this->Mh, x, y);
    MltAdd(beta, *this->Kh, x, alpha, y);
  }

  void MltAddVector(const T& a, const Vector<T>& x, const T& b, Vector<T>& y)
  {
    MltAdd(a*alpha, *this->Mh, x, b, y);
    MltAdd(a*beta, *this->Kh, x, T(1), y);
  }

  // application of preconditioning
  void Solve(const VirtualMatrix<T>& A, const Vector<T>& r, Vector<T>& z)
  {
    for (int i = 0; i < this->n_; i++)
      z(i) = r(i)*precond(i);
  }

  void ComputeSolution(const SeldonTranspose& trans, const Vector<T>& X, Vector<T>& Y)
  {
    // system is assumed to be real symmetric here
    // otherwise you have compute the solution of the transpose system or conjugate transpose
    ComputeSolution(X, Y);
  }

};


int main()
{

// then you can use this class :
MyOwnEigenProblem<double, MyStiffMatrix, MyMassMatrix> var_eig;
Vector<double> lambda, lambda_imag;
Matrix<double> eigen_vec;

// set some parameters
var_eig.SetNbAskedEigenvalues(5);
var_eig.SetTypeSpectrum(var_eig.CENTERED_EIGENVALUES, 0.1);
var_eig.SetComputationalMode(var_eig.SHIFTED_MODE);

// initializing pointers to matrices
var_eig.InitMatrix(K, M);

// then calling computation of eigenvalues
GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);

} 
\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="FactorizeCholeskyMass"></a></div>



<h3>FactorizeCholeskyMass</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
void FactorizeCholeskyMass();
</pre>


<p>This method computes a Cholesky factorization of mass matrix. It is used internally, and should not be called directly. However, if you derive a class for your own eigenproblem, and you want to change how Cholesky factorisation is handled, you can overload this method. Then, look at the example detailed in <a href="#MltCholeskyMass">MltCholeskyMass</a>. </p>

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="MltCholeskyMass"></a></div>



<h3>SolveCholeskyMass, MltCholeskyMass</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
void MltCholeskyMass(SeldonTrans, Vector& x);
void SolveCholeskyMass(SeldonTrans, Vector& x);
</pre>


<p>These methods apply L, L<sup>T</sup>, L<sup>-1</sup> or L<sup>-T</sup> to a given vector. It is used internally, and should not be called directly. However, if you derive a class for your own eigenproblem, and you want to change how Cholesky factorization is handled, you can overload this method as shown in the example below. </p>

<h4>Example :</h4>
\precode
template<class T, class MatStiff, class MatMass>
class MyOwnEigenProblem : public VirtualEigenProblem<T, typename MatStiff::entry_type, typename MatMass::entry_type>
{
  protected:
  // you can add members to handle Cholesky mass matrix
  // for example, you could consider a diagonal with only
  // two coefficient D = [alpha I, 0; 0, beta I]
  double alpha, beta, sqrt_alpha, sqrt_beta;

  public :
  
  // computation of mass in preparation of Cholesky factorization
  void ComputeMassForCholesky()
  {
  }  

  // computation of Cholesky factor
  void FactorizeCholeskyMass()
  {
    // TO DO
  }
  
  // application of L or L^T
  void MltCholesyMass(const SeldonTranspose& TransA, Vector<double>& X)
  {
    // TO DO
  }

  // application of L^-1 or L^-T
  void SolveCholeskyMass(const SeldonTranspose& TransA, Vector<double>& X)
  {
    // TO DO
  }
};

int main()
{

// then you can use this class :
MyOwnEigenProblem<double, MyStiffMatrix, MyMassMatrix> var_eig;
Vector<double> lambda, lambda_imag;
Matrix<double> eigen_vec;

// set some parameters
var_eig.SetNbAskedEigenvalues(5);
// specify that you want to use Cholesky factors of mass matrix
var_eig.SetCholeskyFactoForMass();

// initialized pointers to matrices
var_eig.InitMatrix(K, M);

// then call computation of eigenvalues
GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);

} 
\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="Clear"></a></div>



<h3>Clear</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
void Clear();
</pre>


<p>This method releases memory used for the factorization of mass matrix and/or stiffness matrix. </p>

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="GetEigenvaluesEigenvectors"></a></div>



<h3>GetEigenvaluesEigenvectors</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
void GetEigenvaluesEigenvectors(EigenProblem_Base& var, Vector& lambda, Vector& lambda_imag, Matrix& eigen_vec, int type_solver = 0);
</pre>


<p>This function compute some eigenvalues and eigenvectors of a matrix (dense, sparse or defined by the user) : K x = &lambda; x, or a generalized eigenvalue problem : K x = &lambda; M x, K being called stiffness matrix and M mass matrix. For dense matrices, you can use DenseEigenProblem. For sparse matrices (Seldon format), you can use SparseEigenProblem, it will use direct solvers interfaced by Seldon to solve intermediary linear systems (if needed). For matrices defined by the user, you can evaluate largest eigenvalues with only the matrix vector product thanks to the class VirtualEigenProblem. Eigenvectors are placed in a dense matrix, each column being associated with the corresponding eigenvalue. In the case of real unsymmetric eigenvalue problems, the imaginary part of eigenvalues is placed in vector lambda_imag, and the column i of eigen_vec represents the real part u of the eigenvector, the column i+1 stores the imaginary part v (eigenvectors are then equal to u + i v and u - i v ). An optional last argument can be provided in order to select the eigenvalue solver you prefer. By default it will select (by order of preference) Arpack, Anasazi or Feast.  </p>


\precode

// declaration of the eigenvalue problem
DenseEigenProblem<double, double, Symmetric, RowSymPacked> var_eig;

// setting parameters of eigenproblem
var_eig.SetStoppingCriterion(1e-12);
var_eig.SetNbAskedEigenvalues(10);
// you can ask largest eigenvalues of M^-1 K, smallest 
// or eigenvalues closest to a shift sigma
var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0);

// then you select the computational mode
var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

// giving matrices K and M to the eigenvalue problem
int n = 20;
Matrix<double, Symmetric, RowSymPacked> K(n, n), M(n, n);
K.FillRand(); M.FillRand();
var_eig.InitMatrix(K, M);

// declaring arrays that will contains eigenvalues and eigenvectors
Vector<double> lambda, lambda_imag;
Matrix<double> eigen_vec;
GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);

// you can also impose a solver as a last argument
GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec, TypeEigenvalueSolver::FEAST);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="Init_arpack"></a></div>



<h3>Init</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
void Init(int n, int nev, int ncv, int maxit, double tolerance, string solver_type,
          int mode, string which, char bmat, char HowMny, bool arpack_with_verbose)
</pre>


<p>This function inits parameters related to eigenvalue problem (see Arpack documentation). </p>

<h4>Location :</h4>
<p>ArpackSolver.cxx</p>



<div class="separator"><a name="CheckParameter"></a></div>



<h3>CheckParameter</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
void CheckParameter();
</pre>


<p>This function checks if the parameters - given when calling Init - are correct. </p>

<h4>Location :</h4>
<p>ArpackSolver.cxx</p>



<div class="separator"><a name="arpack_Clear"></a></div>



<h3>Clear</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
void Clear()
</pre>


<p>This function clears memory used by internal arrays. </p>

<h4>Location :</h4>
<p>ArpackSolver.cxx</p>



<div class="separator"><a name="Allocate"></a></div>



<h3>Allocate</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
void Allocate()
</pre>


<p>This function allocates memory used by internal arrays. </p>

<h4>Location :</h4>
<p>ArpackSolver.cxx</p>



<div class="separator"><a name="Deallocate"></a></div>



<h3>Deallocate</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
void Deallocate()
</pre>


<p>This function deallocates memory used by internal arrays. </p>

<h4>Location :</h4>
<p>ArpackSolver.cxx</p>



<div class="separator"><a name="SetArpackVerbose"></a></div>



<h3>SetArpackVerbose</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
void SetArpackVerbose()
</pre>


<p>This function sets verbose mode. </p>

<h4>Location :</h4>
<p>ArpackSolver.cxx</p>



<div class="separator"><a name="ClearArpackVerbose"></a></div>



<h3>ClearArpackVerbose</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
void ClearArpackVerbose()
</pre>


<p>This function returns to silent mode. </p>

<h4>Location :</h4>
<p>ArpackSolver.cxx</p>



<div class="separator"><a name="GetFirstWorkVector"></a></div>



<h3>GetFirstWorkVector</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
T* GetFirstWorkVector()
</pre>


<p>This function returns a pointer to the first work vector. </p>

<h4>Location :</h4>
<p>ArpackSolver.cxx</p>



<div class="separator"><a name="GetSecondWorkVector"></a></div>



<h3>GetSecondWorkVector</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
T* GetSecondWorkVector()
</pre>


<p>This function returns a pointer to the second work vector. </p>

<h4>Location :</h4>
<p>ArpackSolver.cxx</p>



<div class="separator"><a name="GetEigenValue"></a></div>



<h3>GetEigenValue</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
T GetEigenValue(int i)
</pre>


<p>This function returns the i-th eigenvalue. </p>

<h4>Location :</h4>
<p>ArpackSolver.cxx</p>



<div class="separator"><a name="GetEigenVector"></a></div>



<h3>GetEigenVector</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
T* GetEigenVector(int i)
</pre>


<p>This function returns the i-th eigenvector. </p>

<h4>Location :</h4>
<p>ArpackSolver.cxx</p>



<div class="separator"><a name="GetReverseCommunicationFlag"></a></div>



<h3>GetReverseCommunicationFlag, SetReverseCommunicationFlag</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
void SetReverseCommunicationFlag(int flag)
int GetReverseCommunicationFlag()
</pre>


<p>This function gives access to the reverse-communication flag (ido). </p>

<h4>Location :</h4>
<p>ArpackSolver.cxx</p>



<div class="separator"><a name="GetInfoFlag"></a></div>



<h3>GetInfoFlag, SetInfoFlag</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
void SetInfoFlag(int flag)
int GetInfoFlag()
</pre>


<p>This function gives access to the information flag (info). </p>

<h4>Location :</h4>
<p>ArpackSolver.cxx</p>



<div class="separator"><a name="GetConvergedNumber"></a></div>



<h3>GetConvergedNumber</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
int GetConvergedNumber() const
</pre>


<p>This function returns the number of converged eigenvalues. </p>

<h4>Location :</h4>
<p>ArpackSolver.cxx</p>



<div class="separator"><a name="Continue"></a></div>



<h3>Continue</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
bool Continue()
</pre>


<p>This function completes one step of the algorithm, it should return true if the iterative algorithm has ended. </p>

<h4>Location :</h4>
<p>ArpackSolver.cxx</p>



<div class="separator"><a name="Finish"></a></div>



<h3>Finish</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
bool Finish()
</pre>


<p>This function completes the computation of eigenvalues and eigenvectors, it is called once the iterative algorithm has ended. </p>

<h4>Location :</h4>
<p>ArpackSolver.cxx</p>



<div class="separator"><a name="GetEigensolverType_s"></a></div>



<h3>GetEigensolverType, SetEigensolverType</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetEigensolverType(int type);
  int GetEigensolverType();
</pre>


<p><b>SetEigensolverType</b> sets the type of eigensolver to use in Slepc, whereas <b>GetEigensolverType</b> returns this number. You can choose between POWER, SUBSPACE, ARNOLDI, LANCZOS, KRYLOVSCHUR, GD, JD,
          RQCG, LOBPCG, CISS, LAPACK, ARPACK, BLZPACK, TRLAN, BLOPEX, PRIMME or FEAST. This list corresponds to the list provided by <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSType.html#EPSType">Slepc</a>. </p>
	  
<h4>Example :</h4>

\precode

  SparseEigenProblem<T, MatrixK, MatrixM> var_eig;

  var_eig.SetStoppingCriterion(1e-14);
  var_eig.SetNbAskedEigenvalues(nb_eigenval);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

  var_eig.InitMatrix(K, M);

  SlepcParam& param = var_eig.GetSlepcParameters();
  param.SetEigensolverType(param.ARNOLDI);

  // Large eigenvalues
  var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0, var_eig.SORTED_MODULUS);
  
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec, TypeEigenvalueSolver::SLEPC);
  DISP(lambda); DISP(lambda_imag);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolver.cxx</p>



<div class="separator"><a name="GetBlockSize_s"></a></div>



<h3>GetBlockSize, SetBlockSize</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetBlockSize(int n);
  int GetBlockSize();
</pre>


<p><b>SetBlockSize</b> sets the block size to use in Slepc, whereas <b>GetBlockSize</b> returns this number. This block size is used when Seldon calls the following Slepc functions : <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSBLOPEXSetBlockSize.html">EPSBLOPEXSetBlockSize</a>, <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSCISSSetSizes.html">EPSCISSSetSizes</a>, <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSGDSetBlockSize.html">EPSGDSetBlockSize</a>, <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSJDSetBlockSize.html">EPSJDSetBlockSize</a>, <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSLOBPCGSetBlockSize.html">EPSLOBPCGSetBlockSize</a>, <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSPRIMMESetBlockSize.html">EPSPRIMMESetBlockSize</a>. </p>

<h4>Example :</h4>

\precode

  SparseEigenProblem<T, MatrixK, MatrixM> var_eig;

  var_eig.SetStoppingCriterion(1e-14);
  var_eig.SetNbAskedEigenvalues(nb_eigenval);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

  var_eig.InitMatrix(K, M);

  SlepcParam& param = var_eig.GetSlepcParameters();
  param.SetBlockSize(20);

  // Large eigenvalues
  var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0, var_eig.SORTED_MODULUS);
  
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec, TypeEigenvalueSolver::SLEPC);
  DISP(lambda); DISP(lambda_imag);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolverInline.cxx</p>



<div class="separator"><a name="GetMaximumBlockSize_s"></a></div>



<h3>GetMaximumBlockSize, SetMaximumBlockSize</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetMaximumBlockSize(int n);
  int GetMaximumBlockSize();
</pre>


<p><b>SetMaximumBlockSize</b> sets the maximum block size to use in Slepc, whereas <b>GetMaximumBlockSize</b> returns this number. This maximum block size is used when Seldon calls the following Slepc function : <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSCISSSetSizes.html">EPSCISSSetSizes</a>. </p>

<h4>Example :</h4>

\precode

  SparseEigenProblem<T, MatrixK, MatrixM> var_eig;

  var_eig.SetStoppingCriterion(1e-14);
  var_eig.SetNbAskedEigenvalues(nb_eigenval);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

  var_eig.InitMatrix(K, M);

  SlepcParam& param = var_eig.GetSlepcParameters();
  param.SetMaximumBlockSize(20);

  // Large eigenvalues
  var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0, var_eig.SORTED_MODULUS);
  
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec, TypeEigenvalueSolver::SLEPC);
  DISP(lambda); DISP(lambda_imag);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolverInline.cxx</p>



<div class="separator"><a name="GetNumberOfSteps_s"></a></div>



<h3>GetNumberOfSteps, SetNumberOfSteps</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetNumberOfSteps(int n);
  int GetNumberOfSteps();
</pre>


<p><b>SetNumberOfSteps</b> sets the number of steps to use in Slepc, whereas <b>GetNumberOfSteps</b> returns this number. This number of steps is used when Seldon calls the following Slepc functions : <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSBlzpackSetNSteps.html">EPSBlzpackSetNSteps</a>, <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSRQCGSetReset.html">EPSRQCGSetReset</a>. </p>

<h4>Example :</h4>

\precode

  SparseEigenProblem<T, MatrixK, MatrixM> var_eig;

  var_eig.SetStoppingCriterion(1e-14);
  var_eig.SetNbAskedEigenvalues(nb_eigenval);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

  var_eig.InitMatrix(K, M);

  SlepcParam& param = var_eig.GetSlepcParameters();
  param.SetNumberOfSteps(5);
  
  // Large eigenvalues
  var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0, var_eig.SORTED_MODULUS);
  
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec, TypeEigenvalueSolver::SLEPC);
  DISP(lambda); DISP(lambda_imag);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolverInline.cxx</p>



<div class="separator"><a name="GetExtractionType_s"></a></div>



<h3>GetExtractionType, SetExtractionType</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetExtractionType(int n);
  int GetExtractionType();
</pre>


<p><b>SetExtractionType</b> sets the extraction method to use in the solver CISS of Slepc, whereas <b>GetExtractionType</b> returns this method. You can choose between EXTRACT_RITZ and EXTRACT_HANKEL (in class SlepcParam). This method used when Seldon calls the following Slepc function : <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSCISSSetExtraction.html">EPSCISSSetExtraction</a>. </p>

<h4>Example :</h4>

\precode

  SparseEigenProblem<T, MatrixK, MatrixM> var_eig;

  var_eig.SetStoppingCriterion(1e-14);
  var_eig.SetNbAskedEigenvalues(nb_eigenval);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

  var_eig.InitMatrix(K, M);

  SlepcParam& param = var_eig.GetSlepcParameters();
  param.SetExtractionType(param.EXTRACT_RITZ);
  
  // Large eigenvalues
  var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0, var_eig.SORTED_MODULUS);
  
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec, TypeEigenvalueSolver::SLEPC);
  DISP(lambda); DISP(lambda_imag);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolverInline.cxx</p>



<div class="separator"><a name="GetQuadratureRuleType_s"></a></div>



<h3>GetQuadratureRuleType, SetQuadratureRuleType</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetQuadratureRuleType(int n);
  int GetQuadratureRuleType();
</pre>


<p><b>SetQuadratureRuleType</b> sets the quadrature rule to use in the solver CISS of Slepc, whereas <b>GetQuadratureRuleType</b> returns this rule. You can choose between QUADRULE_TRAPEZE and QUADRULE_CHEBY (in class SlepcParam). This method is used when Seldon calls the following Slepc function : <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSCISSSetQuadRule.html">EPSCISSSetQuadRule</a>. </p>

<h4>Example :</h4>

\precode

  SparseEigenProblem<T, MatrixK, MatrixM> var_eig;

  var_eig.SetStoppingCriterion(1e-14);
  var_eig.SetNbAskedEigenvalues(nb_eigenval);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

  var_eig.InitMatrix(K, M);

  SlepcParam& param = var_eig.GetSlepcParameters();
  param.SetQuadratureRuleType(param.QUADRULE_CHEBY);
  
  // Large eigenvalues
  var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0, var_eig.SORTED_MODULUS);
  
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec, TypeEigenvalueSolver::SLEPC);
  DISP(lambda); DISP(lambda_imag);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolverInline.cxx</p>



<div class="separator"><a name="GetInnerSteps_s"></a></div>



<h3>GetInnerSteps, SetInnerSteps</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetInnerSteps(int n);
  int GetInnerSteps();
</pre>


<p><b>SetInnerSteps</b> sets the number of inner steps  to use in the solver CISS of Slepc, whereas <b>GetInnerSteps</b> returns this number. This method is used when Seldon calls the following Slepc function : <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSCISSSetRefinement.html">EPSCISSSetRefinement</a>. </p>

<h4>Example :</h4>

\precode

  SparseEigenProblem<T, MatrixK, MatrixM> var_eig;

  var_eig.SetStoppingCriterion(1e-14);
  var_eig.SetNbAskedEigenvalues(nb_eigenval);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

  var_eig.InitMatrix(K, M);

  SlepcParam& param = var_eig.GetSlepcParameters();
  param.SetInnerSteps(10);
  
  // Large eigenvalues
  var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0, var_eig.SORTED_MODULUS);
  
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec, TypeEigenvalueSolver::SLEPC);
  DISP(lambda); DISP(lambda_imag);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolverInline.cxx</p>



<div class="separator"><a name="GetOuterSteps_s"></a></div>



<h3>GetOuterSteps, SetOuterSteps</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetOuterSteps(int n);
  int GetOuterSteps();
</pre>


<p><b>SetOuterSteps</b> sets the number of outer steps  to use in the solver CISS of Slepc, whereas <b>GetOuterSteps</b> returns this number. This method is used when Seldon calls the following Slepc function : <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSCISSSetRefinement.html">EPSCISSSetRefinement</a>. </p>

<h4>Example :</h4>

\precode

  SparseEigenProblem<T, MatrixK, MatrixM> var_eig;

  var_eig.SetStoppingCriterion(1e-14);
  var_eig.SetNbAskedEigenvalues(nb_eigenval);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

  var_eig.InitMatrix(K, M);

  SlepcParam& param = var_eig.GetSlepcParameters();
  param.SetOuterSteps(10);
  
  // Large eigenvalues
  var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0, var_eig.SORTED_MODULUS);
  
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec, TypeEigenvalueSolver::SLEPC);
  DISP(lambda); DISP(lambda_imag);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolverInline.cxx</p>



<div class="separator"><a name="GetNumberIntegrationPoints_s"></a></div>



<h3>GetNumberIntegrationPoints, SetNumberIntegrationPoints</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetNumberIntegrationPoints(int n);
  int GetNumberIntegrationPoints();
</pre>


<p><b>SetNumberIntegrationPoints</b> sets the number of integration points to use in the solver CISS (or Feast interface) of Slepc, whereas <b>GetNumberIntegrationPoints</b> returns this number. This method is used when Seldon calls the following Slepc functions : <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSCISSSetSizes.html">EPSCISSSetSizes</a>, <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSFEASTSetNumPoints.html">EPSFEASTSetNumPoints</a>. </p>

<h4>Example :</h4>

\precode

  SparseEigenProblem<T, MatrixK, MatrixM> var_eig;

  var_eig.SetStoppingCriterion(1e-14);
  var_eig.SetNbAskedEigenvalues(nb_eigenval);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

  var_eig.InitMatrix(K, M);

  SlepcParam& param = var_eig.GetSlepcParameters();
  param.SetNumberIntegrationPoints(10);
  
  // Large eigenvalues
  var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0, var_eig.SORTED_MODULUS);
  
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec, TypeEigenvalueSolver::SLEPC);
  DISP(lambda); DISP(lambda_imag);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolverInline.cxx</p>



<div class="separator"><a name="GetMomentSize_s"></a></div>



<h3>GetMomentSize, SetMomentSize</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetMomentSize(int n);
  int GetMomentSize();
</pre>


<p><b>SetMomentSize</b> sets the moment size to use in the solver CISS of Slepc, whereas <b>GetMomentSize</b> returns this number. This method is used when Seldon calls the following Slepc function : <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSCISSSetSizes.html">EPSCISSSetSizes</a>. </p>

<h4>Example :</h4>

\precode

  SparseEigenProblem<T, MatrixK, MatrixM> var_eig;

  var_eig.SetStoppingCriterion(1e-14);
  var_eig.SetNbAskedEigenvalues(nb_eigenval);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

  var_eig.InitMatrix(K, M);

  SlepcParam& param = var_eig.GetSlepcParameters();
  param.SetMomentSize(10);
  
  // Large eigenvalues
  var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0, var_eig.SORTED_MODULUS);
  
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec, TypeEigenvalueSolver::SLEPC);
  DISP(lambda); DISP(lambda_imag);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolverInline.cxx</p>



<div class="separator"><a name="GetNumberPartitions_s"></a></div>



<h3>GetNumberPartitions, SetNumberPartitions</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetNumberPartitions(int n);
  int GetNumberPartitions();
</pre>


<p><b>SetNumberPartitions</b> sets the number of partitions to use in the solver CISS of Slepc, whereas <b>GetNumberPartitions</b> returns this number. This method is used when Seldon calls the following Slepc function : <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSCISSSetSizes.html">EPSCISSSetSizes</a>. </p>

<h4>Example :</h4>

\precode

  SparseEigenProblem<T, MatrixK, MatrixM> var_eig;

  var_eig.SetStoppingCriterion(1e-14);
  var_eig.SetNbAskedEigenvalues(nb_eigenval);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

  var_eig.InitMatrix(K, M);

  SlepcParam& param = var_eig.GetSlepcParameters();
  param.SetNumberPartitions(8);
  
  // Large eigenvalues
  var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0, var_eig.SORTED_MODULUS);
  
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec, TypeEigenvalueSolver::SLEPC);
  DISP(lambda); DISP(lambda_imag);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolverInline.cxx</p>



<div class="separator"><a name="GetThresholdRank_s"></a></div>



<h3>GetThresholdRank, SetThresholdRank</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetThresholdRank(double d);
  double GetThresholdRank();
</pre>


<p><b>SetThresholdRank</b> sets the rank threshold to use in the solver CISS of Slepc, whereas <b>GetThresholdRank</b> returns this number. This method is used when Seldon calls the following Slepc function : <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSCISSSetThreshold.html">EPSCISSSetThreshold</a>. </p>

<h4>Example :</h4>

\precode

  SparseEigenProblem<T, MatrixK, MatrixM> var_eig;

  var_eig.SetStoppingCriterion(1e-14);
  var_eig.SetNbAskedEigenvalues(nb_eigenval);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

  var_eig.InitMatrix(K, M);

  SlepcParam& param = var_eig.GetSlepcParameters();
  param.SetThresholdRank(1e-8);
  
  // Large eigenvalues
  var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0, var_eig.SORTED_MODULUS);
  
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec, TypeEigenvalueSolver::SLEPC);
  DISP(lambda); DISP(lambda_imag);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolverInline.cxx</p>



<div class="separator"><a name="GetThresholdSpurious_s"></a></div>



<h3>GetThresholdSpurious, SetThresholdSpurious</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetThresholdSpurious(double d);
  double GetThresholdSpurious();
</pre>


<p><b>SetThresholdSpurious</b> sets the spurious threshold to use in the solver CISS of Slepc, whereas <b>GetThresholdRank</b> returns this number. This method is used when Seldon calls the following Slepc function : <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSCISSSetThreshold.html">EPSCISSSetThreshold</a>. </p>

<h4>Example :</h4>

\precode

  SparseEigenProblem<T, MatrixK, MatrixM> var_eig;

  var_eig.SetStoppingCriterion(1e-14);
  var_eig.SetNbAskedEigenvalues(nb_eigenval);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

  var_eig.InitMatrix(K, M);

  SlepcParam& param = var_eig.GetSlepcParameters();
  param.SetThresholdSpurious(1e-8);
  
  // Large eigenvalues
  var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0, var_eig.SORTED_MODULUS);
  
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec, TypeEigenvalueSolver::SLEPC);
  DISP(lambda); DISP(lambda_imag);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolverInline.cxx</p>



<div class="separator"><a name="GetBorthogonalization_s"></a></div>



<h3>GetBorthogonalization, SetBorthogonalization</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetBorthogonalization(int b);
  int GetBorthogonalization();
</pre>


<p><b>SetBorthogonalization</b> selects the orthogonalization to use in the solver GD/JD of Slepc, whereas <b>GetBorthogonalization</b> returns this orthogonalization. This method is used when Seldon calls the following Slepc functions : <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSGDSetBOrth.html">EPSGDSetBOrth</a>, <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSJDSetBOrth.html">EPSJDSetBOrth</a>. </p>

<h4>Example :</h4>

\precode

  SparseEigenProblem<T, MatrixK, MatrixM> var_eig;

  var_eig.SetStoppingCriterion(1e-14);
  var_eig.SetNbAskedEigenvalues(nb_eigenval);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

  var_eig.InitMatrix(K, M);

  SlepcParam& param = var_eig.GetSlepcParameters();
  param.SetBorthogonalization(true);
  
  // Large eigenvalues
  var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0, var_eig.SORTED_MODULUS);
  
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec, TypeEigenvalueSolver::SLEPC);
  DISP(lambda); DISP(lambda_imag);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolverInline.cxx</p>



<div class="separator"><a name="GetDoubleExpansion_s"></a></div>



<h3>GetDoubleExpansion, SetDoubleExpansion</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetDoubleExpansion(int d);
  int GetDoubleExpansion();
</pre>


<p><b>SetDoubleExpansion</b> selects the expansion to use in the solver GD/JD of Slepc, whereas <b>GetDoubleExpansion</b> returns this expansion. This method is used when Seldon calls the following Slepc functions : <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSGDSetDoubleExpansion.html">EPSGDSetDoubleExpansion</a>, <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSGDSetDoubleExpansion.html">EPSJDSetDoubleExpansion</a>. </p>

<h4>Example :</h4>

\precode

  SparseEigenProblem<T, MatrixK, MatrixM> var_eig;

  var_eig.SetStoppingCriterion(1e-14);
  var_eig.SetNbAskedEigenvalues(nb_eigenval);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

  var_eig.InitMatrix(K, M);

  SlepcParam& param = var_eig.GetSlepcParameters();
  param.SetDoubleExpansion(true);
  
  // Large eigenvalues
  var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0, var_eig.SORTED_MODULUS);
  
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec, TypeEigenvalueSolver::SLEPC);
  DISP(lambda); DISP(lambda_imag);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolverInline.cxx</p>



<div class="separator"><a name="GetInitialSize_s"></a></div>



<h3>GetInitialSize, SetInitialSize</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetInitialSize(int d);
  int GetInitialSize();
</pre>


<p><b>SetInitialSize</b> sets the initial size to use in the solver GD/JD of Slepc, whereas <b>GetInitialSize</b> returns this number. This method is used when Seldon calls the following Slepc functions : <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSGDSetInitialSize.html">EPSGDSetInitialSize</a>, <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSJDSetInitialSize.html">EPSJDSetInitialSize</a>. </p>

<h4>Example :</h4>

\precode

  SparseEigenProblem<T, MatrixK, MatrixM> var_eig;

  var_eig.SetStoppingCriterion(1e-14);
  var_eig.SetNbAskedEigenvalues(nb_eigenval);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

  var_eig.InitMatrix(K, M);

  SlepcParam& param = var_eig.GetSlepcParameters();
  param.SetInitialSize(22);
  
  // Large eigenvalues
  var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0, var_eig.SORTED_MODULUS);
  
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec, TypeEigenvalueSolver::SLEPC);
  DISP(lambda); DISP(lambda_imag);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolverInline.cxx</p>



<div class="separator"><a name="GetKrylovRestart_s"></a></div>



<h3>GetKrylovRestart, SetKrylovRestart</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetKrylovRestart(int d);
  int GetKrylovRestart();
</pre>


<p><b>SetKrylovRestart</b> activates the search with Krylov basis in the solver GD/JD of Slepc, whereas <b>GetKrylovRestart</b> returns this activation. This method is used when Seldon calls the following Slepc functions : <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSGDSetKrylovStart.html">EPSGDSetKrylovStart</a>, <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSJDSetKrylovStart.html">EPSGDSetKrylovStart</a>. </p>

<h4>Example :</h4>

\precode

  SparseEigenProblem<T, MatrixK, MatrixM> var_eig;

  var_eig.SetStoppingCriterion(1e-14);
  var_eig.SetNbAskedEigenvalues(nb_eigenval);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

  var_eig.InitMatrix(K, M);

  SlepcParam& param = var_eig.GetSlepcParameters();
  param.SetKrylovRestart(true);
  
  // Large eigenvalues
  var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0, var_eig.SORTED_MODULUS);
  
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec, TypeEigenvalueSolver::SLEPC);
  DISP(lambda); DISP(lambda_imag);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolverInline.cxx</p>



<div class="separator"><a name="GetRestartNumber_s"></a></div>



<h3>GetRestartNumber, SetRestartNumber</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetRestartNumber(int d);
  int GetRestartNumber();
</pre>


<p><b>SetRestartNumber</b> sets the restart number in the solver GD/JD of Slepc, whereas <b>GetRestartNumber</b> returns this number. This method is used when Seldon calls the following Slepc functions : <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSGDSetRestart.html">EPSGDSetRestart</a>, <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSJDSetRestart.html">EPSJDSetRestart</a>. </p>

<h4>Example :</h4>

\precode

  SparseEigenProblem<T, MatrixK, MatrixM> var_eig;

  var_eig.SetStoppingCriterion(1e-14);
  var_eig.SetNbAskedEigenvalues(nb_eigenval);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

  var_eig.InitMatrix(K, M);

  SlepcParam& param = var_eig.GetSlepcParameters();
  param.SetRestartNumber(20);
  
  // Large eigenvalues
  var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0, var_eig.SORTED_MODULUS);
  
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec, TypeEigenvalueSolver::SLEPC);
  DISP(lambda); DISP(lambda_imag);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolverInline.cxx</p>



<div class="separator"><a name="GetRestartNumberAdd_s"></a></div>



<h3>GetRestartNumberAdd, SetRestartNumberAdd</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetRestartNumberAdd(int d);
  int GetRestartNumberAdd();
</pre>


<p><b>SetRestartNumberAdd</b> sets the number of vectors saved from previous iteration in the solver GD/JD of Slepc, whereas <b>GetRestartNumberAdd</b> returns this number. This method is used when Seldon calls the following Slepc functions : <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSGDSetRestart.html">EPSGDSetRestart</a>, <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSJDSetRestart.html">EPSJDSetRestart</a>. </p>

<h4>Example :</h4>

\precode

  SparseEigenProblem<T, MatrixK, MatrixM> var_eig;

  var_eig.SetStoppingCriterion(1e-14);
  var_eig.SetNbAskedEigenvalues(nb_eigenval);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

  var_eig.InitMatrix(K, M);

  SlepcParam& param = var_eig.GetSlepcParameters();
  param.SetRestartNumberAdd(3);
  
  // Large eigenvalues
  var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0, var_eig.SORTED_MODULUS);
  
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec, TypeEigenvalueSolver::SLEPC);
  DISP(lambda); DISP(lambda_imag);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolverInline.cxx</p>



<div class="separator"><a name="GetNumberConvergedVectors_s"></a></div>



<h3>GetNumberConvergedVectors, SetNumberConvergedVectors, GetNumberConvergedVectorsProjected, SetNumberConvergedVectorsProjected</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetNumberConvergedVectors(int d);
  int GetNumberConvergedVectors();
  void SetNumberConvergedVectorsProjected(int d);
  int GetNumberConvergedVectorsProjected();
</pre>


<p><b>SetNumberConvergedVectors</b> sets the number of converged vectors in the projector for the solver GD/JD of Slepc, whereas <b>GetNumberConvergedVectors</b> returns this number. <b>SetNumberConvergedVectorsProjected</b> sets the number of converged vectors in the projected problem, whereas <b>GetNumberConvergedVectorsProjected</b> returns this number. These method are used when Seldon calls the following Slepc functions : <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSGDSetWindowSizes.html">EPSGDSetWindowSizes</a>, <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSJDSetWindowSizes.html">EPSJDSetWindowSizes</a>. </p>

<h4>Example :</h4>

\precode

  SparseEigenProblem<T, MatrixK, MatrixM> var_eig;

  var_eig.SetStoppingCriterion(1e-14);
  var_eig.SetNbAskedEigenvalues(nb_eigenval);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

  var_eig.InitMatrix(K, M);

  SlepcParam& param = var_eig.GetSlepcParameters();
  param.SetNumberConvergedVectors(10);
  param.SetNumberConvergedVectorsProjected(12);
  
  // Large eigenvalues
  var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0, var_eig.SORTED_MODULUS);
  
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec, TypeEigenvalueSolver::SLEPC);
  DISP(lambda); DISP(lambda_imag);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolverInline.cxx</p>



<div class="separator"><a name="UseNonLockingVariant_s"></a></div>



<h3>UseNonLockingVariant, SetNonLockingVariant</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetNonLockingVariant(bool d);
  bool UseNonLockingVariant();
</pre>


<p><b>SetNonLockingVariant</b> enables the non-locking variant of Slepc solvers, whereas <b>UseNonLockingVariant</b> returns true if the non-locking variant is used. This method is used when Seldon calls the following Slepc functions : <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSKrylovSchurSetLocking.html">EPSKrylovSchurSetLocking</a>, <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSLOBPCGSetLocking.html">EPSLOBPCGSetLocking</a>. </p>

<h4>Example :</h4>

\precode

  SparseEigenProblem<T, MatrixK, MatrixM> var_eig;

  var_eig.SetStoppingCriterion(1e-14);
  var_eig.SetNbAskedEigenvalues(nb_eigenval);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

  var_eig.InitMatrix(K, M);

  SlepcParam& param = var_eig.GetSlepcParameters();
  param.SetNonLockingVariant(true);
  
  // Large eigenvalues
  var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0, var_eig.SORTED_MODULUS);
  
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec, TypeEigenvalueSolver::SLEPC);
  DISP(lambda); DISP(lambda_imag);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolverInline.cxx</p>


<div class="separator"><a name="GetRestartRatio_s"></a></div>



<h3>GetRestartRatio, SetRestartRatio</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetRestartRatio(double d);
  double GetRestartRatio();
</pre>


<p><b>SetRestartRatio</b> sets the restart ratio of Slepc solvers, whereas <b>GetRestartRatio</b> returns this ratio. This method is used when Seldon calls the following Slepc functions : <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSKrylovSchurSetRestart.html">EPSKrylovSchurSetRestart</a>, <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSLOBPCGSetRestart.html">EPSLOBPCGSetRestart</a>. </p>

<h4>Example :</h4>

\precode

  SparseEigenProblem<T, MatrixK, MatrixM> var_eig;

  var_eig.SetStoppingCriterion(1e-14);
  var_eig.SetNbAskedEigenvalues(nb_eigenval);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

  var_eig.InitMatrix(K, M);

  SlepcParam& param = var_eig.GetSlepcParameters();
  param.SetRestartRatio(0.4);
  
  // Large eigenvalues
  var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0, var_eig.SORTED_MODULUS);
  
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec, TypeEigenvalueSolver::SLEPC);
  DISP(lambda); DISP(lambda_imag);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolverInline.cxx</p>



<div class="separator"><a name="GetMethod_s"></a></div>



<h3>GetMethod, SetMethod</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetMethod(string s);
  string GetMethod();
</pre>


<p><b>SetMethod</b> selects the method to use in solver PRIMME of Slepc, whereas <b>GetMethod</b> returns this method. You can choose between DYNAMIC, DEFAULT_MIN_TIME, DEFAULT_MIN_MATVECS, ARNOLDI, GD, GD_PLUSK, GD_OLSEN_PLUSK, JD_OLSEN_PLUSK, RQI, JDQR, JDQMR, JDQMR_ETOL, SUBSPACE_ITERATION, LOBPCG_ORTHOBASIS and LOBPCG_ORTHOBASIS. Those methods are used when Seldon calls the following Slepc function : <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSPRIMMESetMethod.html">EPSPRIMMESetMethod</a>. </p>

<h4>Example :</h4>

\precode

  SparseEigenProblem<T, MatrixK, MatrixM> var_eig;

  var_eig.SetStoppingCriterion(1e-14);
  var_eig.SetNbAskedEigenvalues(nb_eigenval);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

  var_eig.InitMatrix(K, M);

  SlepcParam& param = var_eig.GetSlepcParameters();
  param.SetMethod("DYNAMIC");
  
  // Large eigenvalues
  var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0, var_eig.SORTED_MODULUS);
  
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec, TypeEigenvalueSolver::SLEPC);
  DISP(lambda); DISP(lambda_imag);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolverInline.cxx</p>



<div class="separator"><a name="GetShiftType_s"></a></div>



<h3>GetShiftType, SetShiftType</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void SetShiftType(int s);
  int GetShiftType();
</pre>


<p><b>SetShiftType</b> selects the type of shift strategy to use in solver POWER of Slepc, whereas <b>GetShiftType</b> returns this type. You can choose between SHIFT_CONSTANT, SHIFT_RAYLEIGH and SHIFT_WILKINSON. Those methods are used when Seldon calls the following Slepc function : <a href="http://slepc.upv.es/documentation/current/docs/manualpages/EPS/EPSPowerSetShiftType.html">EPSPowerSetShiftType</a>. </p>

<h4>Example :</h4>

\precode

  SparseEigenProblem<T, MatrixK, MatrixM> var_eig;

  var_eig.SetStoppingCriterion(1e-14);
  var_eig.SetNbAskedEigenvalues(nb_eigenval);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

  var_eig.InitMatrix(K, M);

  SlepcParam& param = var_eig.GetSlepcParameters();
  param.SetShiftType(param.SHIFT_RAYLEIGH);
  
  // Large eigenvalues
  var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0, var_eig.SORTED_MODULUS);
  
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec, TypeEigenvalueSolver::SLEPC);
  DISP(lambda); DISP(lambda_imag);

\endprecode

<h4>Location :</h4>
<p>VirtualEigenvalueSolverInline.cxx</p>


*/
